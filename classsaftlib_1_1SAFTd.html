<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Saftlib Simplified API for Timing: saftlib::SAFTd Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Saftlib Simplified API for Timing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesaftlib.html">saftlib</a></li><li class="navelem"><a class="el" href="classsaftlib_1_1SAFTd.html">SAFTd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsaftlib_1_1SAFTd-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">saftlib::SAFTd Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An encapsulated etherbone::Socket with some extra features.  
 <a href="classsaftlib_1_1SAFTd.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SAFTd_8hpp_source.html">SAFTd.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for saftlib::SAFTd:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd__inherit__graph.png" border="0" usemap="#asaftlib_1_1SAFTd_inherit__map" alt="Inheritance graph"/></div>
<map name="asaftlib_1_1SAFTd_inherit__map" id="asaftlib_1_1SAFTd_inherit__map">
<area shape="rect" title="An encapsulated etherbone::Socket with some extra features." alt="" coords="19,79,123,104"/>
<area shape="rect" title=" " alt="" coords="5,5,136,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for saftlib::SAFTd:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd__coll__graph.png" border="0" usemap="#asaftlib_1_1SAFTd_coll__map" alt="Collaboration graph"/></div>
<map name="asaftlib_1_1SAFTd_coll__map" id="asaftlib_1_1SAFTd_coll__map">
<area shape="rect" title="An encapsulated etherbone::Socket with some extra features." alt="" coords="19,79,123,104"/>
<area shape="rect" title=" " alt="" coords="5,5,136,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3598de1a0aa0ddf897762c36736226e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a3598de1a0aa0ddf897762c36736226e7">SAFTd</a> (<a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *container=nullptr)</td></tr>
<tr class="memdesc:a3598de1a0aa0ddf897762c36736226e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> instance  <a href="classsaftlib_1_1SAFTd.html#a3598de1a0aa0ddf897762c36736226e7">More...</a><br /></td></tr>
<tr class="separator:a3598de1a0aa0ddf897762c36736226e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad799cd918a321d32a177ad77e78f3b0c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#ad799cd918a321d32a177ad77e78f3b0c">AttachDevice</a> (const std::string &amp;name, const std::string &amp;path, int polling_interval_ms=1)</td></tr>
<tr class="memdesc:ad799cd918a321d32a177ad77e78f3b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct saftd to control a new device.  <a href="classsaftlib_1_1SAFTd.html#ad799cd918a321d32a177ad77e78f3b0c">More...</a><br /></td></tr>
<tr class="separator:ad799cd918a321d32a177ad77e78f3b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75f0acfad23741464f2f4464fb0973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#aed75f0acfad23741464f2f4464fb0973">RemoveDevice</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aed75f0acfad23741464f2f4464fb0973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the device from saftlib management.  <a href="classsaftlib_1_1SAFTd.html#aed75f0acfad23741464f2f4464fb0973">More...</a><br /></td></tr>
<tr class="separator:aed75f0acfad23741464f2f4464fb0973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0e4c7d6d1ddf3c8a3d660d08f95656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#abb0e4c7d6d1ddf3c8a3d660d08f95656">Quit</a> ()</td></tr>
<tr class="memdesc:abb0e4c7d6d1ddf3c8a3d660d08f95656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the saftlib daemon to quit.  <a href="classsaftlib_1_1SAFTd.html#abb0e4c7d6d1ddf3c8a3d660d08f95656">More...</a><br /></td></tr>
<tr class="separator:abb0e4c7d6d1ddf3c8a3d660d08f95656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d21bd8623a0f9af01988edab91135a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a77d21bd8623a0f9af01988edab91135a">getSourceVersion</a> () const</td></tr>
<tr class="memdesc:a77d21bd8623a0f9af01988edab91135a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> source version.  <a href="classsaftlib_1_1SAFTd.html#a77d21bd8623a0f9af01988edab91135a">More...</a><br /></td></tr>
<tr class="separator:a77d21bd8623a0f9af01988edab91135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564dc14563e1c8a41477c80dc812607c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a564dc14563e1c8a41477c80dc812607c">getBuildInfo</a> () const</td></tr>
<tr class="memdesc:a564dc14563e1c8a41477c80dc812607c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> build information.  <a href="classsaftlib_1_1SAFTd.html#a564dc14563e1c8a41477c80dc812607c">More...</a><br /></td></tr>
<tr class="separator:a564dc14563e1c8a41477c80dc812607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700f77ea6c096dd296e5014dea6750f7"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a700f77ea6c096dd296e5014dea6750f7">getDevices</a> () const</td></tr>
<tr class="memdesc:a700f77ea6c096dd296e5014dea6750f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all devices attached to saftd.  <a href="classsaftlib_1_1SAFTd.html#a700f77ea6c096dd296e5014dea6750f7">More...</a><br /></td></tr>
<tr class="separator:a700f77ea6c096dd296e5014dea6750f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f86d41be8cc00eb30cd2cf192f3080f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a4f86d41be8cc00eb30cd2cf192f3080f">EbForward</a> (const std::string &amp;saftlib_device)</td></tr>
<tr class="memdesc:a4f86d41be8cc00eb30cd2cf192f3080f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the device that forwards etherbone requests to saftlib_device.  <a href="classsaftlib_1_1SAFTd.html#a4f86d41be8cc00eb30cd2cf192f3080f">More...</a><br /></td></tr>
<tr class="separator:a4f86d41be8cc00eb30cd2cf192f3080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d22e3becfb98182a6cb1592d752e914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a1d22e3becfb98182a6cb1592d752e914">release_irq</a> (eb_address_t irq)</td></tr>
<tr class="memdesc:a1d22e3becfb98182a6cb1592d752e914"><td class="mdescLeft">&#160;</td><td class="mdescRight">release a callback  <a href="classsaftlib_1_1SAFTd.html#a1d22e3becfb98182a6cb1592d752e914">More...</a><br /></td></tr>
<tr class="separator:a1d22e3becfb98182a6cb1592d752e914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a073a19baea868433afabed5266da"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsaftlib_1_1IRQ.html">IRQ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#ab20a073a19baea868433afabed5266da">request_irq</a> (<a class="el" href="classsaftlib_1_1MsiDevice.html">MsiDevice</a> &amp;msi, const std::function&lt; void(eb_data_t)&gt; &amp;slot)</td></tr>
<tr class="memdesc:ab20a073a19baea868433afabed5266da"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a callback function that can be triggered by an MSI (i.e. a wishbone write access from a master on the MSI crossbar) from the hardware. The wishbone address to trigger the callack is returned from the function. The wishbone data is passed as argument to the callback function.  <a href="classsaftlib_1_1SAFTd.html#ab20a073a19baea868433afabed5266da">More...</a><br /></td></tr>
<tr class="separator:ab20a073a19baea868433afabed5266da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e3f7780904d7a476eb0339373aed40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#a51e3f7780904d7a476eb0339373aed40">getObjectPath</a> ()</td></tr>
<tr class="memdesc:a51e3f7780904d7a476eb0339373aed40"><td class="mdescLeft">&#160;</td><td class="mdescRight">the object path of the SAFTd_Service  <a href="classsaftlib_1_1SAFTd.html#a51e3f7780904d7a476eb0339373aed40">More...</a><br /></td></tr>
<tr class="separator:a51e3f7780904d7a476eb0339373aed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617eeb7da78ca99f9105b0ed0767753f"><td class="memItemLeft" align="right" valign="top"><a id="a617eeb7da78ca99f9105b0ed0767753f" name="a617eeb7da78ca99f9105b0ed0767753f"></a>
etherbone::Socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_etherbone_socket</b> ()</td></tr>
<tr class="memdesc:a617eeb7da78ca99f9105b0ed0767753f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the underlying ehterbone::Socket <br /></td></tr>
<tr class="separator:a617eeb7da78ca99f9105b0ed0767753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8822d6b6d2e17ddc506bdaab14f13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsaftlib_1_1TimingReceiver.html">TimingReceiver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#aaf8822d6b6d2e17ddc506bdaab14f13a">getTimingReceiver</a> (const std::string &amp;object_path)</td></tr>
<tr class="memdesc:aaf8822d6b6d2e17ddc506bdaab14f13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access any of the managed TimingReciever driver objects  <a href="classsaftlib_1_1SAFTd.html#aaf8822d6b6d2e17ddc506bdaab14f13a">More...</a><br /></td></tr>
<tr class="separator:aaf8822d6b6d2e17ddc506bdaab14f13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bacacc79522ea468d21534a8aba4a4"><td class="memItemLeft" align="right" valign="top">eb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1SAFTd.html#ab9bacacc79522ea468d21534a8aba4a4">read</a> (eb_address_t address, eb_width_t width, eb_data_t *data)</td></tr>
<tr class="memdesc:ab9bacacc79522ea468d21534a8aba4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the virtual function etherbone::Handler::read.  <a href="classsaftlib_1_1SAFTd.html#ab9bacacc79522ea468d21534a8aba4a4">More...</a><br /></td></tr>
<tr class="separator:ab9bacacc79522ea468d21534a8aba4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3252804d79d7190b18d4f533b2162a3a"><td class="memItemLeft" align="right" valign="top"><a id="a3252804d79d7190b18d4f533b2162a3a" name="a3252804d79d7190b18d4f533b2162a3a"></a>
eb_status_t&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (eb_address_t address, eb_width_t width, eb_data_t data)</td></tr>
<tr class="memdesc:a3252804d79d7190b18d4f533b2162a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the write function is never used, i.e. Hardware never does read requests towards the host. <br /></td></tr>
<tr class="separator:a3252804d79d7190b18d4f533b2162a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An encapsulated etherbone::Socket with some extra features. </p>
<p >In order to receive message passing interrupts (MSIs) from the Hardware, an instance of <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> driver is needed. The name "SAFTd" is kept for backwards compatibility with older saftlib versions, in order to keep the user facing API stable. A better name would be saftlib::EbSocket, because it encapsulates an etherbone::Socket together with some additional functions. <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> provides:</p><ul>
<li>An instance of an etherbone::Socket with a software eb_slave device connected to it that can receive MSIs When an MSI arrives a connected write function will be called with address and data parameters. The <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> class itself is derived from etherbone::Handler and can thus attatch itself to the etherbone::Socket.</li>
<li>Management of registered callbacks and redistribution of incoming MSIs to registered callback functions. There is a convenient high-level interface to register callbacks from <a class="el" href="classsaftlib_1_1MsiDevice.html">saftlib::MsiDevice</a> instances, which represent wischbone masters on the MSI interconnects on the hardware.</li>
<li>A container of <a class="el" href="classsaftlib_1_1TimingReceiver.html" title="A timing receiver.">TimingReceiver</a> objects (std::vector&lt;std::unique_ptr&lt;TimingReceiver&gt; &gt;) and the possibility to add an remove <a class="el" href="classsaftlib_1_1TimingReceiver.html" title="A timing receiver.">TimingReceiver</a> objects at runtime. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3598de1a0aa0ddf897762c36736226e7" name="a3598de1a0aa0ddf897762c36736226e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3598de1a0aa0ddf897762c36736226e7">&#9670;&#160;</a></span>SAFTd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">saftlib::SAFTd::SAFTd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *&#160;</td>
          <td class="paramname"><em>container</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> instance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>if not nullptr, this will be used to register Service objects whenever AttachDevice is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad799cd918a321d32a177ad77e78f3b0c" name="ad799cd918a321d32a177ad77e78f3b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad799cd918a321d32a177ad77e78f3b0c">&#9670;&#160;</a></span>AttachDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string saftlib::SAFTd::AttachDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polling_interval_ms</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct saftd to control a new device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The logical name for the device </td></tr>
    <tr><td class="paramname">path</td><td>The etherbone path where the device can be found </td></tr>
    <tr><td class="paramname">polling_interval_ms</td><td>Is the MSI polling interval in milliseconds which is only relevant for devices that have no native MSI support </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object path of the created device</dd></dl>
<p>Devices are attached to saftlib by specifying a name and a path. The name should denote the logical relationship of the device to saftd. For example, baseboard would be a good name for the timing receiver attached to an SCU. If an exploder is being used to output events to an oscilloscope, a good logical name might be scope. In these examples, the path for the SCU baseboard would be dev/wbm0, and the scope exploder would be dev/ttyUSB3 or similar. This scheme is intended to make it easy to hot-swap hardware. If the exploder dies, you can simply attach a new one under the same logical name, even though the path might be different. <br  />
 </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd_ad799cd918a321d32a177ad77e78f3b0c_cgraph.png" border="0" usemap="#aclasssaftlib_1_1SAFTd_ad799cd918a321d32a177ad77e78f3b0c_cgraph" alt=""/></div>
<map name="aclasssaftlib_1_1SAFTd_ad799cd918a321d32a177ad77e78f3b0c_cgraph" id="aclasssaftlib_1_1SAFTd_ad799cd918a321d32a177ad77e78f3b0c_cgraph">
<area shape="rect" title="Instruct saftd to control a new device." alt="" coords="5,13,193,38"/>
<area shape="rect" href="classsaftbus_1_1Container.html#ade4a52a55f8bed8bff2398da268a7106" title="Insert a Service object and return the saftbus_object_id for this object." alt="" coords="241,5,368,45"/>
</map>
</div>

</div>
</div>
<a id="a4f86d41be8cc00eb30cd2cf192f3080f" name="a4f86d41be8cc00eb30cd2cf192f3080f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f86d41be8cc00eb30cd2cf192f3080f">&#9670;&#160;</a></span>EbForward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string saftlib::SAFTd::EbForward </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>saftlib_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the device that forwards etherbone requests to saftlib_device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saftlib_device</td><td>The name of an attached device. </td></tr>
    <tr><td class="paramname">return</td><td>The name any eb-tool can use to communicate with the hardware attached to saftlib_device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a564dc14563e1c8a41477c80dc812607c" name="a564dc14563e1c8a41477c80dc812607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564dc14563e1c8a41477c80dc812607c">&#9670;&#160;</a></span>getBuildInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string saftlib::SAFTd::getBuildInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> build information. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> build information.</dd></dl>
<p>Information about when and where the <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> was compiled. Format is "built by USERNAME on MMM DD YYYY HH:MM:SS with HOSTNAME running OPERATING-SYSTEM". </p>

</div>
</div>
<a id="a700f77ea6c096dd296e5014dea6750f7" name="a700f77ea6c096dd296e5014dea6750f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700f77ea6c096dd296e5014dea6750f7">&#9670;&#160;</a></span>getDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; saftlib::SAFTd::getDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all devices attached to saftd. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all devices attached to saftd.</dd></dl>
<p>The key is the name of the device as provided to AttachDevice. The value is the dbus path to the Device object, NOT the etherbone path of the device. Each object is guaranteed to implement at least the Device interface, however, typically the objects implement the <a class="el" href="classsaftlib_1_1TimingReceiver.html" title="A timing receiver.">TimingReceiver</a> interface. </p>

</div>
</div>
<a id="a51e3f7780904d7a476eb0339373aed40" name="a51e3f7780904d7a476eb0339373aed40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e3f7780904d7a476eb0339373aed40">&#9670;&#160;</a></span>getObjectPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string saftlib::SAFTd::getObjectPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the object path of the SAFTd_Service </p>
<dl class="section return"><dt>Returns</dt><dd>the object path </dd></dl>

</div>
</div>
<a id="a77d21bd8623a0f9af01988edab91135a" name="a77d21bd8623a0f9af01988edab91135a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d21bd8623a0f9af01988edab91135a">&#9670;&#160;</a></span>getSourceVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string saftlib::SAFTd::getSourceVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> source version. </p>
<p >The version of the <a class="el" href="classsaftlib_1_1SAFTd.html" title="An encapsulated etherbone::Socket with some extra features.">SAFTd</a> source code this daemon was compiled from. Format is "saftlib #.#.# (git-id): MMM DD YYYY HH:MM:SS". <br  />
 </p>

</div>
</div>
<a id="aaf8822d6b6d2e17ddc506bdaab14f13a" name="aaf8822d6b6d2e17ddc506bdaab14f13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8822d6b6d2e17ddc506bdaab14f13a">&#9670;&#160;</a></span>getTimingReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsaftlib_1_1TimingReceiver.html">TimingReceiver</a> * saftlib::SAFTd::getTimingReceiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access any of the managed TimingReciever driver objects </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classsaftlib_1_1TimingReceiver.html" title="A timing receiver.">TimingReceiver</a>, thwows if object_path was not found </dd></dl>

</div>
</div>
<a id="abb0e4c7d6d1ddf3c8a3d660d08f95656" name="abb0e4c7d6d1ddf3c8a3d660d08f95656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0e4c7d6d1ddf3c8a3d660d08f95656">&#9670;&#160;</a></span>Quit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saftlib::SAFTd::Quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the saftlib daemon to quit. </p>
<p >Be absolutely certain before calling this method! All clients will have their future calls throw exceptions. </p>

</div>
</div>
<a id="ab9bacacc79522ea468d21534a8aba4a4" name="ab9bacacc79522ea468d21534a8aba4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bacacc79522ea468d21534a8aba4a4">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eb_status_t saftlib::SAFTd::read </td>
          <td>(</td>
          <td class="paramtype">eb_address_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eb_width_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eb_data_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the virtual function etherbone::Handler::read. </p>
<p >read/write virtual functions from etherbone::Handler base class are used to receive incoming etherbone read/write requests from the device. Only write is ever used, an incoming MSI (Message Signal Interrupt) causes a write request. <br  />
 </p>

</div>
</div>
<a id="a1d22e3becfb98182a6cb1592d752e914" name="a1d22e3becfb98182a6cb1592d752e914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d22e3becfb98182a6cb1592d752e914">&#9670;&#160;</a></span>release_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saftlib::SAFTd::release_irq </td>
          <td>(</td>
          <td class="paramtype">eb_address_t&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release a callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>the address to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed75f0acfad23741464f2f4464fb0973" name="aed75f0acfad23741464f2f4464fb0973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed75f0acfad23741464f2f4464fb0973">&#9670;&#160;</a></span>RemoveDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saftlib::SAFTd::RemoveDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the device from saftlib management. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The logical name for the device <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd_aed75f0acfad23741464f2f4464fb0973_cgraph.png" border="0" usemap="#aclasssaftlib_1_1SAFTd_aed75f0acfad23741464f2f4464fb0973_cgraph" alt=""/></div>
<map name="aclasssaftlib_1_1SAFTd_aed75f0acfad23741464f2f4464fb0973_cgraph" id="aclasssaftlib_1_1SAFTd_aed75f0acfad23741464f2f4464fb0973_cgraph">
<area shape="rect" title="Remove the device from saftlib management." alt="" coords="5,13,204,38"/>
<area shape="rect" href="classsaftbus_1_1Container.html#a6b9d836b8bd0da4b1aeac77f1c493c1c" title="remove an object" alt="" coords="252,5,379,45"/>
<area shape="rect" href="classsaftbus_1_1Container.html#af0eeeb7c164d95a953ba206a7975f186" title="checks if object_path exists and if the object itself or any of its children are owned" alt="" coords="427,5,553,45"/>
</map>
</div>

</div>
</div>
<a id="ab20a073a19baea868433afabed5266da" name="ab20a073a19baea868433afabed5266da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a073a19baea868433afabed5266da">&#9670;&#160;</a></span>request_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsaftlib_1_1IRQ.html">IRQ</a> &gt; saftlib::SAFTd::request_irq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsaftlib_1_1MsiDevice.html">MsiDevice</a> &amp;&#160;</td>
          <td class="paramname"><em>msi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(eb_data_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register a callback function that can be triggered by an MSI (i.e. a wishbone write access from a master on the MSI crossbar) from the hardware. The wishbone address to trigger the callack is returned from the function. The wishbone data is passed as argument to the callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>of type <a class="el" href="classsaftlib_1_1MsiDevice.html">MsiDevice</a> or derived from <a class="el" href="classsaftlib_1_1MsiDevice.html">MsiDevice</a>. MsiDevices are masters on the MSI-crossbar interconnect </td></tr>
    <tr><td class="paramname">slot</td><td>function object that is called when an MSI with the correct address (return value of this fuction) arrives </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unique_ptr&lt;IRQ&gt; that can be used to obtain the address to trigger the slot function. The irq is released in the destructor of <a class="el" href="classsaftlib_1_1IRQ.html" title="Represents an IRQ that is managed by saftlib.">IRQ</a>, i.e. it needs to be stored as long as the interrupt is needed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_cgraph.png" border="0" usemap="#aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_cgraph" alt=""/></div>
<map name="aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_cgraph" id="aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_cgraph">
<area shape="rect" title="register a callback function that can be triggered by an MSI (i.e. a wishbone write access from a mas..." alt="" coords="5,29,180,55"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_icgraph.png" border="0" usemap="#aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_icgraph" alt=""/></div>
<map name="aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_icgraph" id="aclasssaftlib_1_1SAFTd_ab20a073a19baea868433afabed5266da_icgraph">
<area shape="rect" title="register a callback function that can be triggered by an MSI (i.e. a wishbone write access from a mas..." alt="" coords="188,29,363,55"/>
<area shape="rect" href="classsaftlib_1_1OpenDevice.html#a4e38cad1c324517bf1653e773e764c2d" title="open given etherbone_path on given socket." alt="" coords="5,22,140,62"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="SAFTd_8hpp_source.html">SAFTd.hpp</a></li>
<li>src/SAFTd.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
