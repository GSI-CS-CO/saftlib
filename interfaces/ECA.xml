<node>
  <!-- de.gsi.saftlib.ECA:
       @short_description: Trigger actions upon receipt of timing events.

       This interface controls Event-Condition-Action (ECA) hardware present
       in timing receivers.  It configures both hardware and software filter
       rules (conditions) which may match a range of event IDs. When a
       an event is received, each matching condition creates an action which
       is forwarded to either a hardware channel or a software callback.
    -->
  <interface name="de.gsi.saftlib.ECA">
    <!-- Name: A human-readable string describing this instance of the ECA.
         Typically, this describes the VHDL project file which instantiated
         the ECA hardware.
      -->
    <property name="Name" type="s" access="read"/>
    
    <!-- Frequency: The base operating frequency of the ECA.
         This determines the resolution of events. If the frequency is
         125MHz then the ECA can only output one action per 8ns interval.
      -->
    <property name="Frequency" type="s" access="read"/>
    
    <!-- CurrentTime: Return the current time.
         @result: The number of cycles since 1970
      -->
    <method name="CurrentTime">
      <arg direction="out" type="t" name="result"/>
    </method>
    
    <!-- Channels: The hardware output channels of the ECA.
         Each returned object path implements the ECA_Channel interface.
      -->
    <property name="Channels" type="as" access="read"/>
    
    <!-- Free: The number of additional conditions that may be created.
         The ECA has limited hardware resources in its match table. This
         software interface does its best to pack as many conditions as
         possible into the table via compression.  This property reports the
         worst-case remaining space in the hardware.  If this property
         returns 5, then you are guaranteed to be able to create at least 5
         more conditions. Note that (de)activating a condition will also
         affect resource consumption and thus this property.
      -->
    <property name="Free" type="u" access="read"/>
    
    <!-- Conditions: All configured conditions.
         This lists all conditions currently managed by this ECA instance.
         Each returned object path implements the ECA_Condition interface.
      -->
    <property name="Conditions" type="as" access="read"/>

    <!-- NewCondition: Create a condition to match incoming events
         @first:  First event ID to monitor (inclusive)
         @last:   Last event ID to monitor (exclusive)
         @offset: Delay in ECA clock cycles between event and action
         @result: Object path to the created ECA_Condition

         This method creates a new condition that matches events whose
         identifier lies in the range [first, last). The offset acts as a
         delay which is added to the event's execution timestamp to
         determine the timestamp when the matching condition fires its
         action. The returned object path implements the ECA_Condition
         interface and has SoftwareActive=true.
      -->
    <method name="NewCondition">
      <arg direction="in" type="t" name="first"/>
      <arg direction="in" type="t" name="last"/>
      <arg direction="in" type="x" name="offset"/>
      <arg direction="out" type="s" name="result"/>
    </method>
    
    <!-- InjectEvent: Simulate the receipt of a timing event.
         @event: The event identifier which is matched against [first, last)
         @param: The parameter field, whose meaning depends on the event ID.
         @time:  The execution time for the event, added to condition offsets.
         @tef:   The timing extension field, used for sub-cycle timing (use 0).
         
         Sometimes it is useful to simulate the receipt of a timing event. 
         This allows software to test that configured conditions lead to the
         desired behaviour without needing the data master to send anything.
      -->
    <method name="InjectEvent">
      <arg direction="in" type="t" name="event"/>
      <arg direction="in" type="t" name="param"/>
      <arg direction="in" type="t" name="time"/>
      <arg direction="in" type="u" name="tef"/>
    </method>
    
    <!-- Overflow: Software is unable to keep up with hardware.
         When the ECA is configured to report actions to software via the
         SoftwareActive property of an ECA_Condition, matching events are
         translated into actions put into a hardware FIFO.  The saftlib ECA
         service drains this FIFO as quickly as it can, but it may be the
         case that the configured conditions match so many events that the
         software cannot empty the FIFO as fast as it is filled.  In this
         case, the FIFO can overflow and this signal will be raised.  This
         indicates a fatal ECA configuration error and operator intervention
         is likely required.
      -->
    <signal name="Overflow"/>
    
    <!-- Conflict:  Two software actions should be run simultaneously.
         @event:    The event identifier of the conflicting action.
         @param:    The parameter field, whose meaning depends on the event ID.
         @time:     The action execution timestamp (event time + offset).
         @tef:      The timing extension field.

         Saftlib ensures that a single timing message will never generate
         conflicting actions in software.  In the case of multiple
         interested clients, it internally creates a single condition and
         replicates the resulting action to all interested parties. 
         
         However, two different timing events can still lead to a conflict. 
         This is especially likely if both events have the same execution
         timestamp, but it can also occur if there exist two conditions
         whose offsets combine with the timing events to produce conflicting
         action timestamps. This signal only reports the conflicting action
         which was arbitrarily (4us) delayed.
         
         This signal is only generated for conflicting software actions.
         To monitor conflicting actions in hardware, see the ECA_Channel's
         Conflict signal.
      -->
    <signal name="Conflict">
      <arg name="event"    type="t"/>
      <arg name="param"    type="t"/>
      <arg name="time"     type="t"/>
      <arg name="tef"      type="u"/>
    </signal>
    
    <!-- Late:      A software action should have been run in the past.
         @event:    The event identifier of the late action.
         @param:    The parameter field, whose meaning depends on the event ID.
         @time:     The desired execution timestamp (event time + offset).
         @tef:      The timing extension field.

         If a timing event arrives which is late, resulting actions may have
         been scheduled for execution in the past.  This may also be the
         result of large negative offsets.  In either case, the action will
         be executed after an implementation-defined delay (<4us).  This
         signal is raised to inform the operator of the misconfiguration. 

         This signal is only generated for late software actions, and does
         not include lateness due to delays in software. To monitor late
         actions in hardware, see the ECA_Channel's Late signal.
      -->
    <signal name="Late">
      <arg name="event"    type="t"/>
      <arg name="param"    type="t"/>
      <arg name="time"     type="t"/>
      <arg name="tef"      type="u"/>
    </signal>
    
  </interface>
</node>
