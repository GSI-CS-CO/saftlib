<node xmlns:xi="http://www.w3.org/2001/XInclude" name="MasterFunctionGenerator">
  <annotation name="de.gsi.saftlib.name" value="de.gsi.saftlib"/>
  
  <!-- Include base interfaces -->
  <xi:include href="Owned.xml"/>
  
  <!-- de.gsi.saftlib.MasterFunctionGenerator:
      @short_description: Interface to multiple Function Generators
      Operation of function generators is aggregated to reduce
      the number of d-bus operations required.
   -->
  <interface name="de.gsi.saftlib.MasterFunctionGenerator">
    
   
    <!-- StartTag: The SCUbus tag which causes function generation to begin.
         All function generators under control of the Master use the same tag.
         If the function generator is Armed and this tag is sent to the SCUbus, 
         then the function generator will begin generating the output waveform.
         StartTag may only be set when the FunctionGenerator is not Enabled.
      -->
    <property name="StartTag" type="u" access="readwrite"/>

    <!-- Arm: Enable all function generators that have data and arm them.
         A function generator can only be Armed if FillLevel is non-zero. 
         An Enabled function generator can not be Armed again until it
         either completes waveform generation or the user calls Abort.
         Arming a function generator takes time.
         Wait for Armed to transition to true before sending StartTag.
      -->
    <method name="Arm"/>
    
    <!-- Abort: Abort waveform generation in all function generators.
         This directs the hardware to stop waveform generation. If the
         function generator was Armed, it is disarmed and disabled, without
         outputting any waveform data. If the function generator is running, 
         output is Stopped at the current value and disabled. Aborting a
         function generator takes time, so even after a call to Abort,
         the function generator might still be Started. However, it will
         reach the disabled state as quickly as it can, transitioning
         through Stopped as usual. If the Owner of a FunctionGenerator 
         quits without running Disown, the Abort is run automatically.
      -->
    <method name="Abort"/>
   
    
    
<!-- AppendParameterSets: For each function generator, append parameter tuples describing the waveform to generate.
				 Each parameter is sent as a vector of vectors: per FG then per tuple element
				 
         @coeff_a:  Quadratic coefficient (a), 16-bit signed
         @coeff_b:  Linear coefficient (b),    16-bit signed
         @coeff_c:  Constant coefficient (c),  32-bit signed
         @step:     Number of interpolated samples (0=250, 1=500, 2=1000, 3=2000, 4=4000, 5=8000, 6=16000, or 7=32000)
         @freq:     Output sample frequency (0=16kHz, 1=32kHz, 2=64kHz, 3=125kHz, 4=250kHz, 5=500kHz, 6=1MHz, or 7=2MHz)
         @shift_a:  Exponent of coeff_a, 6-bit unsigned; a = coeff_a*2^shift_a
         @shift_b:  Exponent of coeff_b, 6-bit unsigned; b = coeff_b*2^shift_b
         @arm:			If true, arm each function generator that received data and wait for acknowledgement
         @low_fill: Fill level remains too low
				

         This function appends the parameter vectors (which must be equal in length)
         to the FIFO of remaining waveform to generate. Each parameter set (coefficients)
         describes a number of output samples in the generated wave form. Parameter
         sets are executed in order until no more remain.
         
         If the fill level is not high enough, this method returns true. 
         Only once this function has returned false can you await the Refill signal.

         At each step, the function generator outputs high_bits(c*2^32 + b*t + c*t*t),
         where t ranges from 0 to numSteps-1. high_bits are the high OutputWindowSize
         bits of the resulting 64-bit signed value.
      -->
    <method name="AppendParameterSets">
      <arg direction="in" type="AAn" name="coeff_a"/>
      <arg direction="in" type="AAn" name="coeff_b"/>
      <arg direction="in" type="AAi" name="coeff_c"/>
      <arg direction="in" type="AAy" name="step"/>
      <arg direction="in" type="AAy" name="freq"/>
      <arg direction="in" type="AAy" name="shift_a"/>
      <arg direction="in" type="AAy" name="shift_b"/>
      <arg direction="in" type="b" name="arm"/>
      <arg direction="out" type="b" name="low_fill"/>
    </method>
        
    
    <!-- Flush: Empty the parameter tuple set of all function generators.
         Flush may only be called when not Enabled.
         Flush does not clear the ExecutedParameterCount.
      -->
    <method name="Flush"/>


    <!-- Stopped:                   Function generation has ended as expected.
         @time:                     Time when function generation ended in nanoseconds since 1970
         @abort:                    stopped due to a call to Abort
         @hardwareMacroUnderflow:   A fatal error, indicating the SCUbus is congested
         @microControllerUnderflow: A fatal error, indicating the host CPU is overloaded

         The function generator stops either successfully (when all data has been sent), or 
         it stops due to an error. When an error occurs, the function generator stops and 
         holds its most recent value. This can occur due to two causes:

         hardwareMacroUnderflow, a fatal error indicating the hardware ran out of data.
         If the SCUbus is too busy, it can happen that the waveform data stored in the 
         function generator HDL is not refilled in time. This error can only be mitigated 
         by ensuring that the function generator does not share the SCUbus with other users.

         microControllerUnderflow, a fatal error indicating the microcontroller ran out of data.
         If the host CPU running this software is too busy, it can happen that the waveform
         data is not delivered to the microcontroller before the microcontroller runs out of data.
         This error can be mitigated by reducing the number of busy processes running on the system.

         Once the function generator has stopped, ExecutedParameterCount remains valid until the
         next time the function generator starts. After stopping, regardless of if the generation
         was successful or not, the parameter FIFO is cleared, Enabled is false, and this signal emitted.
      -->
    <signal name="Stopped">
      <arg name="name"                     type="s"/>
      <arg name="time"                     type="t"/>
      <arg name="aborted"                  type="b"/>
      <arg name="hardwareMacroUnderflow"   type="b"/>
      <arg name="microControllerUnderflow" type="b"/>
    </signal>

    <!-- Interface TBD
    -->

    <method name="SetActiveFunctionGenerators">
      <arg direction="in" type="as" name="names"/>
    </method>

    <!-- ReadExecutedParameterCounts: Number of parameter tuples executed by each function generator
         @result:                     Number tuples executed by hardware.
         This counts the total number of parameter tuples executed since the last
         Started signal. Obviously, if the function generator is running, the returned
         value will be old.
      -->

    <method name="ReadExecutedParameterCounts">
      <arg direction="out" type="Au" name="result"/>
    </method>

    <!-- ReadFillLevels: Remaining waveform data in nanoseconds for each FG.
         @result:       Remaining waveform data in nanoseconds for each FG.
         The SAFTd has sufficient parameters buffered to supply the function generator with 
         data for the specified time in nanoseconds. Note, due to the slow nature of software,
         if the function generator is currently running, the read value will already be 
         out-of-date upon return. This property should be used for informational use only.
      -->
    <method name="ReadFillLevels">
      <arg direction="out" type="at" name="result"/>
    </method>

    <!-- ReadNames: Read the name for each FG.
         @names:       Name of each FG.
      -->
    <method name="ReadNames">
      <arg direction="out" type="as" name="names"/>
    </method>


    <!-- ReadArmed: Read the armed state of each FG.
         @armed_states:       State of each FG.
      -->
    
    <method name="ReadArmed">
      <arg direction="out" type="ab" name="armed_states"/>
    </method>

    <!-- ReadEnabled: Read the enabled state of each FG.
         @enabled_states:       State of each FG.
      -->
    <method name="ReadEnabled">
      <arg direction="out" type="ab" name="enabled_states"/>
    </method>


  </interface>
</node>
