<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Saftlib Simplified API for Timing: saftlib::ActionSink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Saftlib Simplified API for Timing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesaftlib.html">saftlib</a></li><li class="navelem"><a class="el" href="classsaftlib_1_1ActionSink.html">ActionSink</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsaftlib_1_1ActionSink-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">saftlib::ActionSink Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An output through which actions flow.  
 <a href="classsaftlib_1_1ActionSink.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ActionSink_8hpp_source.html">ActionSink.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for saftlib::ActionSink:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1ActionSink__inherit__graph.png" border="0" usemap="#asaftlib_1_1ActionSink_inherit__map" alt="Inheritance graph"/></div>
<map name="asaftlib_1_1ActionSink_inherit__map" id="asaftlib_1_1ActionSink_inherit__map">
<area shape="rect" title="An output through which actions flow." alt="" coords="157,104,284,129"/>
<area shape="rect" href="classsaftlib_1_1EmbeddedCPUActionSink.html" title="An output through which EmbeddedCPU actions flow." alt="" coords="332,5,547,31"/>
<area shape="rect" href="classsaftlib_1_1Output.html" title="An output through which on/off actions flow." alt="" coords="388,55,491,80"/>
<area shape="rect" href="classsaftlib_1_1SCUbusActionSink.html" title="An output through which SCUbus actions flow." alt="" coords="352,104,527,129"/>
<area shape="rect" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow." alt="" coords="350,153,529,179"/>
<area shape="rect" href="classsaftlib_1_1WbmActionSink.html" title="An output through which Wbm actions flow." alt="" coords="361,203,517,228"/>
<area shape="rect" href="classsaftlib_1_1Owned.html" title="An object which can grant exclusive access if used in a saftbus::Container." alt="" coords="5,104,109,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for saftlib::ActionSink:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1ActionSink__coll__graph.png" border="0" usemap="#asaftlib_1_1ActionSink_coll__map" alt="Collaboration graph"/></div>
<map name="asaftlib_1_1ActionSink_coll__map" id="asaftlib_1_1ActionSink_coll__map">
<area shape="rect" title="An output through which actions flow." alt="" coords="223,316,350,341"/>
<area shape="rect" href="classsaftlib_1_1Owned.html" title="An object which can grant exclusive access if used in a saftbus::Container." alt="" coords="5,155,109,180"/>
<area shape="rect" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns..." alt="" coords="134,155,223,180"/>
<area shape="rect" href="classsaftlib_1_1MsiDevice.html" title=" " alt="" coords="117,80,241,105"/>
<area shape="rect" href="classsaftlib_1_1SdbDevice.html" title="SdbDevices calls sdb_find_by_identity and keeps the starting address of the device registers." alt="" coords="115,5,242,31"/>
<area shape="rect" href="classsaftbus_1_1SourceHandle.html" title="unique identifier for an event source in a saftbus::Loop" alt="" coords="247,155,401,180"/>
<area shape="rect" href="classsaftbus_1_1Container.html" title="A Container of Service objects." alt="" coords="425,155,551,180"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaftlib_1_1ActionSink_1_1Record.html">Record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a11e32ac36270d075c4e0916b5cd62a89"><td class="memItemLeft" align="right" valign="top"><a id="a11e32ac36270d075c4e0916b5cd62a89" name="a11e32ac36270d075c4e0916b5cd62a89"></a>
typedef std::map&lt; unsigned, std::unique_ptr&lt; <a class="el" href="classsaftlib_1_1Condition.html">Condition</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Conditions</b></td></tr>
<tr class="separator:a11e32ac36270d075c4e0916b5cd62a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91a218439cdfc43e2adfc543254aa894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a91a218439cdfc43e2adfc543254aa894">ActionSink</a> (<a class="el" href="classsaftlib_1_1ECA.html">ECA</a> &amp;eca, const std::string &amp;action_sink_object_path, const std::string &amp;name, unsigned channel, unsigned num, <a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *container=nullptr)</td></tr>
<tr class="memdesc:a91a218439cdfc43e2adfc543254aa894"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> constructor.  <a href="classsaftlib_1_1ActionSink.html#a91a218439cdfc43e2adfc543254aa894">More...</a><br /></td></tr>
<tr class="separator:a91a218439cdfc43e2adfc543254aa894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3596e1d3db031efb531a49648fe524f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#ac3596e1d3db031efb531a49648fe524f">ToggleActive</a> ()</td></tr>
<tr class="memdesc:ac3596e1d3db031efb531a49648fe524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically toggle the active status of conditions.  <a href="classsaftlib_1_1ActionSink.html#ac3596e1d3db031efb531a49648fe524f">More...</a><br /></td></tr>
<tr class="separator:ac3596e1d3db031efb531a49648fe524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2058baeebb6fcea54becfd3c6e1f650a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a2058baeebb6fcea54becfd3c6e1f650a">ReadFill</a> ()</td></tr>
<tr class="memdesc:a2058baeebb6fcea54becfd3c6e1f650a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the number of currently pending actions.  <a href="classsaftlib_1_1ActionSink.html#a2058baeebb6fcea54becfd3c6e1f650a">More...</a><br /></td></tr>
<tr class="separator:a2058baeebb6fcea54becfd3c6e1f650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64bc4d3793c224481a5ad9456f872c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#ad64bc4d3793c224481a5ad9456f872c1">getAllConditions</a> () const</td></tr>
<tr class="memdesc:ad64bc4d3793c224481a5ad9456f872c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">All conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.  <a href="classsaftlib_1_1ActionSink.html#ad64bc4d3793c224481a5ad9456f872c1">More...</a><br /></td></tr>
<tr class="separator:ad64bc4d3793c224481a5ad9456f872c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531fd07eb708e9b0f1d6ada36dcd241d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a531fd07eb708e9b0f1d6ada36dcd241d">getActiveConditions</a> () const</td></tr>
<tr class="memdesc:a531fd07eb708e9b0f1d6ada36dcd241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All active conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.  <a href="classsaftlib_1_1ActionSink.html#a531fd07eb708e9b0f1d6ada36dcd241d">More...</a><br /></td></tr>
<tr class="separator:a531fd07eb708e9b0f1d6ada36dcd241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdbc979c119d797fc5f92be6a90f20e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#adfdbc979c119d797fc5f92be6a90f20e">getInactiveConditions</a> () const</td></tr>
<tr class="memdesc:adfdbc979c119d797fc5f92be6a90f20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">All inactive conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.  <a href="classsaftlib_1_1ActionSink.html#adfdbc979c119d797fc5f92be6a90f20e">More...</a><br /></td></tr>
<tr class="separator:adfdbc979c119d797fc5f92be6a90f20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3c553a6ce7103e4a032775ec01436"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#af5b3c553a6ce7103e4a032775ec01436">getMinOffset</a> () const</td></tr>
<tr class="memdesc:af5b3c553a6ce7103e4a032775ec01436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum allowed offset (nanoseconds) usable in NewCondition.  <a href="classsaftlib_1_1ActionSink.html#af5b3c553a6ce7103e4a032775ec01436">More...</a><br /></td></tr>
<tr class="separator:af5b3c553a6ce7103e4a032775ec01436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f05833d1e4acaabce3b3b870da9643"><td class="memItemLeft" align="right" valign="top"><a id="a58f05833d1e4acaabce3b3b870da9643" name="a58f05833d1e4acaabce3b3b870da9643"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMinOffset</b> (int64_t val)</td></tr>
<tr class="separator:a58f05833d1e4acaabce3b3b870da9643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968da9e51228e652c1dcb704e43a1c10"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a968da9e51228e652c1dcb704e43a1c10">getMaxOffset</a> () const</td></tr>
<tr class="memdesc:a968da9e51228e652c1dcb704e43a1c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed offset (nanoseconds) usable in NewCondition.  <a href="classsaftlib_1_1ActionSink.html#a968da9e51228e652c1dcb704e43a1c10">More...</a><br /></td></tr>
<tr class="separator:a968da9e51228e652c1dcb704e43a1c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9990320b37fdce12a796fc558bfdf5"><td class="memItemLeft" align="right" valign="top"><a id="a6b9990320b37fdce12a796fc558bfdf5" name="a6b9990320b37fdce12a796fc558bfdf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxOffset</b> (int64_t val)</td></tr>
<tr class="separator:a6b9990320b37fdce12a796fc558bfdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268d9a4ff28151bfdcdec95d77d8b649"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a268d9a4ff28151bfdcdec95d77d8b649">getLatency</a> () const</td></tr>
<tr class="memdesc:a268d9a4ff28151bfdcdec95d77d8b649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nanoseconds between event and earliest execution of an action.  <a href="classsaftlib_1_1ActionSink.html#a268d9a4ff28151bfdcdec95d77d8b649">More...</a><br /></td></tr>
<tr class="separator:a268d9a4ff28151bfdcdec95d77d8b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9a3f0be3696893879c33fe9a837ce"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#ae3a9a3f0be3696893879c33fe9a837ce">getEarlyThreshold</a> () const</td></tr>
<tr class="memdesc:ae3a9a3f0be3696893879c33fe9a837ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions further into the future than this are early.  <a href="classsaftlib_1_1ActionSink.html#ae3a9a3f0be3696893879c33fe9a837ce">More...</a><br /></td></tr>
<tr class="separator:ae3a9a3f0be3696893879c33fe9a837ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a315d0ff908152b1f9b80b25e1ec5"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a209a315d0ff908152b1f9b80b25e1ec5">getCapacity</a> () const</td></tr>
<tr class="memdesc:a209a315d0ff908152b1f9b80b25e1ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of actions queueable without Overflow.  <a href="classsaftlib_1_1ActionSink.html#a209a315d0ff908152b1f9b80b25e1ec5">More...</a><br /></td></tr>
<tr class="separator:a209a315d0ff908152b1f9b80b25e1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91841b67ca1f4a683aac1b847ef91d60"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a91841b67ca1f4a683aac1b847ef91d60">getMostFull</a> () const</td></tr>
<tr class="memdesc:a91841b67ca1f4a683aac1b847ef91d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the largest number of pending actions seen.  <a href="classsaftlib_1_1ActionSink.html#a91841b67ca1f4a683aac1b847ef91d60">More...</a><br /></td></tr>
<tr class="separator:a91841b67ca1f4a683aac1b847ef91d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ecb0c08bbe4b9a588d5af41c849b54"><td class="memItemLeft" align="right" valign="top"><a id="ad3ecb0c08bbe4b9a588d5af41c849b54" name="ad3ecb0c08bbe4b9a588d5af41c849b54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMostFull</b> (uint16_t val)</td></tr>
<tr class="separator:ad3ecb0c08bbe4b9a588d5af41c849b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4986fd88c94fa4fb769ce879c24482fa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a4986fd88c94fa4fb769ce879c24482fa">getSignalRate</a> () const</td></tr>
<tr class="memdesc:a4986fd88c94fa4fb769ce879c24482fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum interval between updates (nanoseconds, default 100ms).  <a href="classsaftlib_1_1ActionSink.html#a4986fd88c94fa4fb769ce879c24482fa">More...</a><br /></td></tr>
<tr class="separator:a4986fd88c94fa4fb769ce879c24482fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36acd67d643860b55ea2c6cd548287f"><td class="memItemLeft" align="right" valign="top"><a id="ab36acd67d643860b55ea2c6cd548287f" name="ab36acd67d643860b55ea2c6cd548287f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSignalRate</b> (uint64_t val)</td></tr>
<tr class="separator:ab36acd67d643860b55ea2c6cd548287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e65092d2ad770c9d2c97bd510af4069"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a1e65092d2ad770c9d2c97bd510af4069">getOverflowCount</a> () const</td></tr>
<tr class="memdesc:a1e65092d2ad770c9d2c97bd510af4069"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions lost due to Overflow.  <a href="classsaftlib_1_1ActionSink.html#a1e65092d2ad770c9d2c97bd510af4069">More...</a><br /></td></tr>
<tr class="separator:a1e65092d2ad770c9d2c97bd510af4069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b22395233a96156b2b7636f4a39c23"><td class="memItemLeft" align="right" valign="top"><a id="aa1b22395233a96156b2b7636f4a39c23" name="aa1b22395233a96156b2b7636f4a39c23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setOverflowCount</b> (uint64_t val)</td></tr>
<tr class="separator:aa1b22395233a96156b2b7636f4a39c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec200e16687ea6ddf5fcefb167b710b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a5ec200e16687ea6ddf5fcefb167b710b">getActionCount</a> () const</td></tr>
<tr class="memdesc:a5ec200e16687ea6ddf5fcefb167b710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions processed by the Sink.  <a href="classsaftlib_1_1ActionSink.html#a5ec200e16687ea6ddf5fcefb167b710b">More...</a><br /></td></tr>
<tr class="separator:a5ec200e16687ea6ddf5fcefb167b710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa836f9681e7c824e27217a1afdebc9d6"><td class="memItemLeft" align="right" valign="top"><a id="aa836f9681e7c824e27217a1afdebc9d6" name="aa836f9681e7c824e27217a1afdebc9d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setActionCount</b> (uint64_t val)</td></tr>
<tr class="separator:aa836f9681e7c824e27217a1afdebc9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feb6dfc8976ac410f9d0149d65e7c4a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a7feb6dfc8976ac410f9d0149d65e7c4a">getLateCount</a> () const</td></tr>
<tr class="memdesc:a7feb6dfc8976ac410f9d0149d65e7c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions delivered late.  <a href="classsaftlib_1_1ActionSink.html#a7feb6dfc8976ac410f9d0149d65e7c4a">More...</a><br /></td></tr>
<tr class="separator:a7feb6dfc8976ac410f9d0149d65e7c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1170366e3a62c2dd20bb1b3ae57e251e"><td class="memItemLeft" align="right" valign="top"><a id="a1170366e3a62c2dd20bb1b3ae57e251e" name="a1170366e3a62c2dd20bb1b3ae57e251e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLateCount</b> (uint64_t val)</td></tr>
<tr class="separator:a1170366e3a62c2dd20bb1b3ae57e251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834817f91ab96c29edd430688515702f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a834817f91ab96c29edd430688515702f">getEarlyCount</a> () const</td></tr>
<tr class="memdesc:a834817f91ab96c29edd430688515702f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions delivered early.  <a href="classsaftlib_1_1ActionSink.html#a834817f91ab96c29edd430688515702f">More...</a><br /></td></tr>
<tr class="separator:a834817f91ab96c29edd430688515702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27932c6badc855d149b1e73bb25690"><td class="memItemLeft" align="right" valign="top"><a id="abf27932c6badc855d149b1e73bb25690" name="abf27932c6badc855d149b1e73bb25690"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setEarlyCount</b> (uint64_t val)</td></tr>
<tr class="separator:abf27932c6badc855d149b1e73bb25690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46de5a53a6684af364093dff6ef4b07"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#aa46de5a53a6684af364093dff6ef4b07">getConflictCount</a> () const</td></tr>
<tr class="memdesc:aa46de5a53a6684af364093dff6ef4b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions which conflicted.  <a href="classsaftlib_1_1ActionSink.html#aa46de5a53a6684af364093dff6ef4b07">More...</a><br /></td></tr>
<tr class="separator:aa46de5a53a6684af364093dff6ef4b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640b2cc9398ef67e1bb2c1452476220"><td class="memItemLeft" align="right" valign="top"><a id="a7640b2cc9398ef67e1bb2c1452476220" name="a7640b2cc9398ef67e1bb2c1452476220"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setConflictCount</b> (uint64_t val)</td></tr>
<tr class="separator:a7640b2cc9398ef67e1bb2c1452476220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2462d9b1ff9be4aaf2fa1fcdc2ed108"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#aa2462d9b1ff9be4aaf2fa1fcdc2ed108">getDelayedCount</a> () const</td></tr>
<tr class="memdesc:aa2462d9b1ff9be4aaf2fa1fcdc2ed108"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of actions which have been delayed.  <a href="classsaftlib_1_1ActionSink.html#aa2462d9b1ff9be4aaf2fa1fcdc2ed108">More...</a><br /></td></tr>
<tr class="separator:aa2462d9b1ff9be4aaf2fa1fcdc2ed108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022469d2530f77e711d3156571f9280e"><td class="memItemLeft" align="right" valign="top"><a id="a022469d2530f77e711d3156571f9280e" name="a022469d2530f77e711d3156571f9280e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDelayedCount</b> (uint64_t val)</td></tr>
<tr class="separator:a022469d2530f77e711d3156571f9280e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a78614d67296c5aace4d03f815e27a"><td class="memItemLeft" align="right" valign="top"><a id="aa1a78614d67296c5aace4d03f815e27a" name="aa1a78614d67296c5aace4d03f815e27a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compile</b> ()</td></tr>
<tr class="separator:aa1a78614d67296c5aace4d03f815e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af482dd1de5d98120fb9b6b1ffc01d450"><td class="memItemLeft" align="right" valign="top"><a id="af482dd1de5d98120fb9b6b1ffc01d450" name="af482dd1de5d98120fb9b6b1ffc01d450"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getObjectName</b> () const</td></tr>
<tr class="separator:af482dd1de5d98120fb9b6b1ffc01d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae066d79e3002b7fad67600c439a57c5a"><td class="memItemLeft" align="right" valign="top"><a id="ae066d79e3002b7fad67600c439a57c5a" name="ae066d79e3002b7fad67600c439a57c5a"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getObjectPath</b> () const</td></tr>
<tr class="separator:ae066d79e3002b7fad67600c439a57c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647c179bc02de8ae110751aff24dc075"><td class="memItemLeft" align="right" valign="top"><a id="a647c179bc02de8ae110751aff24dc075" name="a647c179bc02de8ae110751aff24dc075"></a>
const Conditions &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getConditions</b> () const</td></tr>
<tr class="separator:a647c179bc02de8ae110751aff24dc075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb01b779fe703fffd2127f01999637a"><td class="memItemLeft" align="right" valign="top"><a id="a1fb01b779fe703fffd2127f01999637a" name="a1fb01b779fe703fffd2127f01999637a"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>getChannel</b> () const</td></tr>
<tr class="separator:a1fb01b779fe703fffd2127f01999637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e40840aaf9423c8492172a584da163"><td class="memItemLeft" align="right" valign="top"><a id="a83e40840aaf9423c8492172a584da163" name="a83e40840aaf9423c8492172a584da163"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>getNum</b> () const</td></tr>
<tr class="separator:a83e40840aaf9423c8492172a584da163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7315772a10cb31f46121e5a470a0d13"><td class="memItemLeft" align="right" valign="top"><a id="ad7315772a10cb31f46121e5a470a0d13" name="ad7315772a10cb31f46121e5a470a0d13"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>receiveMSI</b> (uint8_t code)</td></tr>
<tr class="separator:ad7315772a10cb31f46121e5a470a0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20f2442e226fd30c2290ed6e2f67ead"><td class="memItemLeft" align="right" valign="top"><a id="ac20f2442e226fd30c2290ed6e2f67ead" name="ac20f2442e226fd30c2290ed6e2f67ead"></a>
<a class="el" href="classsaftlib_1_1Condition.html">Condition</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCondition</b> (const std::string object_path)</td></tr>
<tr class="separator:ac20f2442e226fd30c2290ed6e2f67ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0380422e04a04fee1686998f603e65"><td class="memItemLeft" align="right" valign="top"><a id="a0e0380422e04a04fee1686998f603e65" name="a0e0380422e04a04fee1686998f603e65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeCondition</b> (<a class="el" href="classsaftlib_1_1Condition.html">Condition</a> *condition)</td></tr>
<tr class="separator:a0e0380422e04a04fee1686998f603e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9186a7a9c38cc5c4825fa63b83ad0"><td class="memItemLeft" align="right" valign="top"><a id="ad2d9186a7a9c38cc5c4825fa63b83ad0" name="ad2d9186a7a9c38cc5c4825fa63b83ad0"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>createConditionNumber</b> ()</td></tr>
<tr class="separator:ad2d9186a7a9c38cc5c4825fa63b83ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e4c9912ba1fcfb7c1921470c4a716"><td class="memTemplParams" colspan="2"><a id="a638e4c9912ba1fcfb7c1921470c4a716" name="a638e4c9912ba1fcfb7c1921470c4a716"></a>
template&lt;typename ConditionType , typename... Args&gt; </td></tr>
<tr class="memitem:a638e4c9912ba1fcfb7c1921470c4a716"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NewConditionHelper</b> (bool active, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a638e4c9912ba1fcfb7c1921470c4a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsaftlib_1_1Owned"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsaftlib_1_1Owned')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsaftlib_1_1Owned.html">saftlib::Owned</a></td></tr>
<tr class="memitem:a6fd444d03c519e4206b7c8d9cf747a73 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top"><a id="a6fd444d03c519e4206b7c8d9cf747a73" name="a6fd444d03c519e4206b7c8d9cf747a73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Owned</b> (<a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *container)</td></tr>
<tr class="separator:a6fd444d03c519e4206b7c8d9cf747a73 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63407cdecd04640d0332a82f8c2eee3 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top"><a id="af63407cdecd04640d0332a82f8c2eee3" name="af63407cdecd04640d0332a82f8c2eee3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_service</b> (<a class="el" href="classsaftbus_1_1Service.html">saftbus::Service</a> *service)</td></tr>
<tr class="memdesc:af63407cdecd04640d0332a82f8c2eee3 inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class only works if it has access to a service object. Service object are created after Driver class object. In order to create a functional <a class="el" href="classsaftlib_1_1Owned.html" title="An object which can grant exclusive access if used in a saftbus::Container.">Owned</a> object, the service object pointer must be passed to using this function;. <br /></td></tr>
<tr class="separator:af63407cdecd04640d0332a82f8c2eee3 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b4aa95a92f5d76345ba45b6d7c8830 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top"><a id="aa5b4aa95a92f5d76345ba45b6d7c8830" name="aa5b4aa95a92f5d76345ba45b6d7c8830"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_service</b> ()</td></tr>
<tr class="memdesc:aa5b4aa95a92f5d76345ba45b6d7c8830 inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a service of an <a class="el" href="classsaftlib_1_1Owned.html" title="An object which can grant exclusive access if used in a saftbus::Container.">Owned</a> object is destroyed, this method must be passed as destruction callback (or must be called in the destruction callback) <br /></td></tr>
<tr class="separator:aa5b4aa95a92f5d76345ba45b6d7c8830 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b02c4fb8d41c6ed6d31d3298458a3a inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#ae3b02c4fb8d41c6ed6d31d3298458a3a">Disown</a> ()</td></tr>
<tr class="memdesc:ae3b02c4fb8d41c6ed6d31d3298458a3a inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the object.  <a href="classsaftlib_1_1Owned.html#ae3b02c4fb8d41c6ed6d31d3298458a3a">More...</a><br /></td></tr>
<tr class="separator:ae3b02c4fb8d41c6ed6d31d3298458a3a inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fee085da8848580430315c096b97a9 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#a12fee085da8848580430315c096b97a9">Own</a> ()</td></tr>
<tr class="memdesc:a12fee085da8848580430315c096b97a9 inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim ownership of the object.  <a href="classsaftlib_1_1Owned.html#a12fee085da8848580430315c096b97a9">More...</a><br /></td></tr>
<tr class="separator:a12fee085da8848580430315c096b97a9 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edbd7f8eaba4db9d7c5b3df8a8653da inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#a5edbd7f8eaba4db9d7c5b3df8a8653da">getOwner</a> () const</td></tr>
<tr class="memdesc:a5edbd7f8eaba4db9d7c5b3df8a8653da inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client which owns this object.  <a href="classsaftlib_1_1Owned.html#a5edbd7f8eaba4db9d7c5b3df8a8653da">More...</a><br /></td></tr>
<tr class="separator:a5edbd7f8eaba4db9d7c5b3df8a8653da inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e13cb75a8c354cb3200b7cf6f21587 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#a08e13cb75a8c354cb3200b7cf6f21587">getDestructible</a> () const</td></tr>
<tr class="memdesc:a08e13cb75a8c354cb3200b7cf6f21587 inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can the object be destroyed.  <a href="classsaftlib_1_1Owned.html#a08e13cb75a8c354cb3200b7cf6f21587">More...</a><br /></td></tr>
<tr class="separator:a08e13cb75a8c354cb3200b7cf6f21587 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b11219ef81bac010e4453c9193873a7 inherit pub_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#a2b11219ef81bac010e4453c9193873a7">Destroy</a> ()</td></tr>
<tr class="memdesc:a2b11219ef81bac010e4453c9193873a7 inherit pub_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this object.  <a href="classsaftlib_1_1Owned.html#a2b11219ef81bac010e4453c9193873a7">More...</a><br /></td></tr>
<tr class="separator:a2b11219ef81bac010e4453c9193873a7 inherit pub_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab3ec1bfa7c396e16fd407e36d9946937"><td class="memItemLeft" align="right" valign="top"><a id="ab3ec1bfa7c396e16fd407e36d9946937" name="ab3ec1bfa7c396e16fd407e36d9946937"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OverflowCount</b></td></tr>
<tr class="separator:ab3ec1bfa7c396e16fd407e36d9946937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b09dbe1e0771023dbd6478e1755489"><td class="memItemLeft" align="right" valign="top"><a id="a51b09dbe1e0771023dbd6478e1755489" name="a51b09dbe1e0771023dbd6478e1755489"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ActionCount</b></td></tr>
<tr class="separator:a51b09dbe1e0771023dbd6478e1755489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e5ee4a85cd4e0250fe099b0471c14e"><td class="memItemLeft" align="right" valign="top"><a id="ac6e5ee4a85cd4e0250fe099b0471c14e" name="ac6e5ee4a85cd4e0250fe099b0471c14e"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LateCount</b></td></tr>
<tr class="separator:ac6e5ee4a85cd4e0250fe099b0471c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa92fc752cdc979fca68f12d9db69361"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, uint32_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#aaa92fc752cdc979fca68f12d9db69361">SigLate</a></td></tr>
<tr class="memdesc:aaa92fc752cdc979fca68f12d9db69361"><td class="mdescLeft">&#160;</td><td class="mdescRight">: An example of a late action since last LateCount change.  <a href="classsaftlib_1_1ActionSink.html#aaa92fc752cdc979fca68f12d9db69361">More...</a><br /></td></tr>
<tr class="separator:aaa92fc752cdc979fca68f12d9db69361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09287cce75f077354881f7d80f4bd9fd"><td class="memItemLeft" align="right" valign="top"><a id="a09287cce75f077354881f7d80f4bd9fd" name="a09287cce75f077354881f7d80f4bd9fd"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EarlyCount</b></td></tr>
<tr class="separator:a09287cce75f077354881f7d80f4bd9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394db701a5f5b62b33a9f00025875e64"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, uint32_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a394db701a5f5b62b33a9f00025875e64">SigEarly</a></td></tr>
<tr class="memdesc:a394db701a5f5b62b33a9f00025875e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example of an early action since last EarlyCount change.  <a href="classsaftlib_1_1ActionSink.html#a394db701a5f5b62b33a9f00025875e64">More...</a><br /></td></tr>
<tr class="separator:a394db701a5f5b62b33a9f00025875e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681bad746dbaf618f529cecbbd7f27d5"><td class="memItemLeft" align="right" valign="top"><a id="a681bad746dbaf618f529cecbbd7f27d5" name="a681bad746dbaf618f529cecbbd7f27d5"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConflictCount</b></td></tr>
<tr class="separator:a681bad746dbaf618f529cecbbd7f27d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540ccc530877c27b128c85aedd22df5b"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, uint64_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a540ccc530877c27b128c85aedd22df5b">SigConflict</a></td></tr>
<tr class="memdesc:a540ccc530877c27b128c85aedd22df5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example of a conflict since last ConflictCount change.  <a href="classsaftlib_1_1ActionSink.html#a540ccc530877c27b128c85aedd22df5b">More...</a><br /></td></tr>
<tr class="separator:a540ccc530877c27b128c85aedd22df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a536e7edd884433738c4abaf1f78893"><td class="memItemLeft" align="right" valign="top"><a id="a9a536e7edd884433738c4abaf1f78893" name="a9a536e7edd884433738c4abaf1f78893"></a>
sigc::signal&lt; void, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DelayedCount</b></td></tr>
<tr class="separator:a9a536e7edd884433738c4abaf1f78893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b3e60a608f736de640575408e85538"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, uint64_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1ActionSink.html#a07b3e60a608f736de640575408e85538">SigDelayed</a></td></tr>
<tr class="memdesc:a07b3e60a608f736de640575408e85538"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example of a delayed action the last DelayedCount change.  <a href="classsaftlib_1_1ActionSink.html#a07b3e60a608f736de640575408e85538">More...</a><br /></td></tr>
<tr class="separator:a07b3e60a608f736de640575408e85538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classsaftlib_1_1Owned"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classsaftlib_1_1Owned')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classsaftlib_1_1Owned.html">saftlib::Owned</a></td></tr>
<tr class="memitem:af862c85d43711cfae99d864a6a77e07d inherit pub_attribs_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaftlib_1_1Owned.html#af862c85d43711cfae99d864a6a77e07d">Destroyed</a></td></tr>
<tr class="memdesc:af862c85d43711cfae99d864a6a77e07d inherit pub_attribs_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object was destroyed.  <a href="classsaftlib_1_1Owned.html#af862c85d43711cfae99d864a6a77e07d">More...</a><br /></td></tr>
<tr class="separator:af862c85d43711cfae99d864a6a77e07d inherit pub_attribs_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a61e5782b6b4a2a182250e97e726c34af"><td class="memItemLeft" align="right" valign="top"><a id="a61e5782b6b4a2a182250e97e726c34af" name="a61e5782b6b4a2a182250e97e726c34af"></a>
<a class="el" href="structsaftlib_1_1ActionSink_1_1Record.html">Record</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fetchError</b> (uint8_t code) const</td></tr>
<tr class="separator:a61e5782b6b4a2a182250e97e726c34af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e896d8483be5b794f2bdf9ff51efb8"><td class="memItemLeft" align="right" valign="top"><a id="a45e896d8483be5b794f2bdf9ff51efb8" name="a45e896d8483be5b794f2bdf9ff51efb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateOverflow</b> () const</td></tr>
<tr class="separator:a45e896d8483be5b794f2bdf9ff51efb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14694e67d2416c5c1c23bc7ace2e589"><td class="memItemLeft" align="right" valign="top"><a id="ac14694e67d2416c5c1c23bc7ace2e589" name="ac14694e67d2416c5c1c23bc7ace2e589"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateAction</b> () const</td></tr>
<tr class="separator:ac14694e67d2416c5c1c23bc7ace2e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ee69f090b4653069a49b8813eb08c8"><td class="memItemLeft" align="right" valign="top"><a id="a39ee69f090b4653069a49b8813eb08c8" name="a39ee69f090b4653069a49b8813eb08c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateLate</b> () const</td></tr>
<tr class="separator:a39ee69f090b4653069a49b8813eb08c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c269406da1c0f4a1bcca4575b80cad0"><td class="memItemLeft" align="right" valign="top"><a id="a4c269406da1c0f4a1bcca4575b80cad0" name="a4c269406da1c0f4a1bcca4575b80cad0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateEarly</b> () const</td></tr>
<tr class="separator:a4c269406da1c0f4a1bcca4575b80cad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d5f15aea8d096c05b395e487438d5"><td class="memItemLeft" align="right" valign="top"><a id="a0f1d5f15aea8d096c05b395e487438d5" name="a0f1d5f15aea8d096c05b395e487438d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateConflict</b> () const</td></tr>
<tr class="separator:a0f1d5f15aea8d096c05b395e487438d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c62bd7a1362162cc2298507c6a9f74b"><td class="memItemLeft" align="right" valign="top"><a id="a0c62bd7a1362162cc2298507c6a9f74b" name="a0c62bd7a1362162cc2298507c6a9f74b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateDelayed</b> () const</td></tr>
<tr class="separator:a0c62bd7a1362162cc2298507c6a9f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsaftlib_1_1Owned"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsaftlib_1_1Owned')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsaftlib_1_1Owned.html">saftlib::Owned</a></td></tr>
<tr class="memitem:aed5da441e1295bf94b4b327e8a9445c2 inherit pro_methods_classsaftlib_1_1Owned"><td class="memItemLeft" align="right" valign="top"><a id="aed5da441e1295bf94b4b327e8a9445c2" name="aed5da441e1295bf94b4b327e8a9445c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ownerOnly</b> () const</td></tr>
<tr class="memdesc:aed5da441e1295bf94b4b327e8a9445c2 inherit pro_methods_classsaftlib_1_1Owned"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the caller is not the owner. <br /></td></tr>
<tr class="separator:aed5da441e1295bf94b4b327e8a9445c2 inherit pro_methods_classsaftlib_1_1Owned"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a842848609c75b078c68290c537561aaa"><td class="memItemLeft" align="right" valign="top"><a id="a842848609c75b078c68290c537561aaa" name="a842848609c75b078c68290c537561aaa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>object_path</b></td></tr>
<tr class="separator:a842848609c75b078c68290c537561aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ffba0ef9f2e6a8649d52c064bdf2c0"><td class="memItemLeft" align="right" valign="top"><a id="aa7ffba0ef9f2e6a8649d52c064bdf2c0" name="aa7ffba0ef9f2e6a8649d52c064bdf2c0"></a>
<a class="el" href="classsaftlib_1_1ECA.html">ECA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>eca</b></td></tr>
<tr class="separator:aa7ffba0ef9f2e6a8649d52c064bdf2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f706adf5c416c32794db8e6acaaf826"><td class="memItemLeft" align="right" valign="top"><a id="a4f706adf5c416c32794db8e6acaaf826" name="a4f706adf5c416c32794db8e6acaaf826"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a4f706adf5c416c32794db8e6acaaf826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f68d163a1d4a0b59387b249c2396f7"><td class="memItemLeft" align="right" valign="top"><a id="ad1f68d163a1d4a0b59387b249c2396f7" name="ad1f68d163a1d4a0b59387b249c2396f7"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b></td></tr>
<tr class="separator:ad1f68d163a1d4a0b59387b249c2396f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f8cc29361ba0849d4ad59f1323ed3"><td class="memItemLeft" align="right" valign="top"><a id="a875f8cc29361ba0849d4ad59f1323ed3" name="a875f8cc29361ba0849d4ad59f1323ed3"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>num</b></td></tr>
<tr class="separator:a875f8cc29361ba0849d4ad59f1323ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af113aa12789602a9807059485f9c1b78"><td class="memItemLeft" align="right" valign="top"><a id="af113aa12789602a9807059485f9c1b78" name="af113aa12789602a9807059485f9c1b78"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>minOffset</b></td></tr>
<tr class="separator:af113aa12789602a9807059485f9c1b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9b7b39629a7f76c248a35136e0aec9"><td class="memItemLeft" align="right" valign="top"><a id="aca9b7b39629a7f76c248a35136e0aec9" name="aca9b7b39629a7f76c248a35136e0aec9"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxOffset</b></td></tr>
<tr class="separator:aca9b7b39629a7f76c248a35136e0aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0529dd5e9a701b3f31e28ef022576509"><td class="memItemLeft" align="right" valign="top"><a id="a0529dd5e9a701b3f31e28ef022576509" name="a0529dd5e9a701b3f31e28ef022576509"></a>
std::chrono::nanoseconds&#160;</td><td class="memItemRight" valign="bottom"><b>signalRate</b></td></tr>
<tr class="separator:a0529dd5e9a701b3f31e28ef022576509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62af869d51941be4ca05d889bd23519d"><td class="memItemLeft" align="right" valign="top"><a id="a62af869d51941be4ca05d889bd23519d" name="a62af869d51941be4ca05d889bd23519d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>overflowCount</b></td></tr>
<tr class="separator:a62af869d51941be4ca05d889bd23519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd76e7edad0f1282410f8837f2f9bc25"><td class="memItemLeft" align="right" valign="top"><a id="afd76e7edad0f1282410f8837f2f9bc25" name="afd76e7edad0f1282410f8837f2f9bc25"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>actionCount</b></td></tr>
<tr class="separator:afd76e7edad0f1282410f8837f2f9bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf86af8562405a09713be597afad4405"><td class="memItemLeft" align="right" valign="top"><a id="aaf86af8562405a09713be597afad4405" name="aaf86af8562405a09713be597afad4405"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>lateCount</b></td></tr>
<tr class="separator:aaf86af8562405a09713be597afad4405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ef357cf1aa2dda68342b570cd7fcb"><td class="memItemLeft" align="right" valign="top"><a id="a835ef357cf1aa2dda68342b570cd7fcb" name="a835ef357cf1aa2dda68342b570cd7fcb"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>earlyCount</b></td></tr>
<tr class="separator:a835ef357cf1aa2dda68342b570cd7fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af22bbfc514f8426aa21b8eee817f4b"><td class="memItemLeft" align="right" valign="top"><a id="a5af22bbfc514f8426aa21b8eee817f4b" name="a5af22bbfc514f8426aa21b8eee817f4b"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>conflictCount</b></td></tr>
<tr class="separator:a5af22bbfc514f8426aa21b8eee817f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79c9b4f88dcc5c2569d5b2652a072ae"><td class="memItemLeft" align="right" valign="top"><a id="af79c9b4f88dcc5c2569d5b2652a072ae" name="af79c9b4f88dcc5c2569d5b2652a072ae"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>delayedCount</b></td></tr>
<tr class="separator:af79c9b4f88dcc5c2569d5b2652a072ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade17da0966be39f1ffbb2ceaf9afe5b1"><td class="memItemLeft" align="right" valign="top"><a id="ade17da0966be39f1ffbb2ceaf9afe5b1" name="ade17da0966be39f1ffbb2ceaf9afe5b1"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>overflowUpdate</b></td></tr>
<tr class="separator:ade17da0966be39f1ffbb2ceaf9afe5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8661a1a2ccbc403b6354b890bcf5900a"><td class="memItemLeft" align="right" valign="top"><a id="a8661a1a2ccbc403b6354b890bcf5900a" name="a8661a1a2ccbc403b6354b890bcf5900a"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>actionUpdate</b></td></tr>
<tr class="separator:a8661a1a2ccbc403b6354b890bcf5900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa525aa1a83c9fd395c09589f2ab1dbd"><td class="memItemLeft" align="right" valign="top"><a id="aaa525aa1a83c9fd395c09589f2ab1dbd" name="aaa525aa1a83c9fd395c09589f2ab1dbd"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>lateUpdate</b></td></tr>
<tr class="separator:aaa525aa1a83c9fd395c09589f2ab1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053d86aadfbaf2bf6ff5edbb04536847"><td class="memItemLeft" align="right" valign="top"><a id="a053d86aadfbaf2bf6ff5edbb04536847" name="a053d86aadfbaf2bf6ff5edbb04536847"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>earlyUpdate</b></td></tr>
<tr class="separator:a053d86aadfbaf2bf6ff5edbb04536847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeb48dfb2f92c366cfc00e8b1479d17"><td class="memItemLeft" align="right" valign="top"><a id="a0aeb48dfb2f92c366cfc00e8b1479d17" name="a0aeb48dfb2f92c366cfc00e8b1479d17"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>conflictUpdate</b></td></tr>
<tr class="separator:a0aeb48dfb2f92c366cfc00e8b1479d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1cbed45b383b5122f959407d6113b9"><td class="memItemLeft" align="right" valign="top"><a id="aaf1cbed45b383b5122f959407d6113b9" name="aaf1cbed45b383b5122f959407d6113b9"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>delayedUpdate</b></td></tr>
<tr class="separator:aaf1cbed45b383b5122f959407d6113b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2974c147fa3fb8db58b2525fd988e67"><td class="memItemLeft" align="right" valign="top"><a id="aa2974c147fa3fb8db58b2525fd988e67" name="aa2974c147fa3fb8db58b2525fd988e67"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>latency</b></td></tr>
<tr class="separator:aa2974c147fa3fb8db58b2525fd988e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0347de74551700d85cd48b20d1bf6e11"><td class="memItemLeft" align="right" valign="top"><a id="a0347de74551700d85cd48b20d1bf6e11" name="a0347de74551700d85cd48b20d1bf6e11"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>earlyThreshold</b></td></tr>
<tr class="separator:a0347de74551700d85cd48b20d1bf6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b184e8cd9cc2e12cd807294014ee085"><td class="memItemLeft" align="right" valign="top"><a id="a8b184e8cd9cc2e12cd807294014ee085" name="a8b184e8cd9cc2e12cd807294014ee085"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b></td></tr>
<tr class="separator:a8b184e8cd9cc2e12cd807294014ee085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb34c5bc252269c39eec7b853642927"><td class="memItemLeft" align="right" valign="top"><a id="a5fb34c5bc252269c39eec7b853642927" name="a5fb34c5bc252269c39eec7b853642927"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>overflowPending</b></td></tr>
<tr class="separator:a5fb34c5bc252269c39eec7b853642927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67201f61b3316448a6fd8523df41b2e5"><td class="memItemLeft" align="right" valign="top"><a id="a67201f61b3316448a6fd8523df41b2e5" name="a67201f61b3316448a6fd8523df41b2e5"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>actionPending</b></td></tr>
<tr class="separator:a67201f61b3316448a6fd8523df41b2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c065451a7c049ba94d3a42fc646cd2"><td class="memItemLeft" align="right" valign="top"><a id="ab1c065451a7c049ba94d3a42fc646cd2" name="ab1c065451a7c049ba94d3a42fc646cd2"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>latePending</b></td></tr>
<tr class="separator:ab1c065451a7c049ba94d3a42fc646cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fc3a44a5661079d3938863e3318269"><td class="memItemLeft" align="right" valign="top"><a id="a71fc3a44a5661079d3938863e3318269" name="a71fc3a44a5661079d3938863e3318269"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>earlyPending</b></td></tr>
<tr class="separator:a71fc3a44a5661079d3938863e3318269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8242c1aa5993514a9eed8221319cab"><td class="memItemLeft" align="right" valign="top"><a id="acc8242c1aa5993514a9eed8221319cab" name="acc8242c1aa5993514a9eed8221319cab"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conflictPending</b></td></tr>
<tr class="separator:acc8242c1aa5993514a9eed8221319cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ace3110c3641f725c5f5674decef7b2"><td class="memItemLeft" align="right" valign="top"><a id="a9ace3110c3641f725c5f5674decef7b2" name="a9ace3110c3641f725c5f5674decef7b2"></a>
<a class="el" href="classsaftbus_1_1SourceHandle.html">saftbus::SourceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>delayedPending</b></td></tr>
<tr class="separator:a9ace3110c3641f725c5f5674decef7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acaf1d891d81249161b026bfdc3217d"><td class="memItemLeft" align="right" valign="top"><a id="a1acaf1d891d81249161b026bfdc3217d" name="a1acaf1d891d81249161b026bfdc3217d"></a>
Conditions&#160;</td><td class="memItemRight" valign="bottom"><b>conditions</b></td></tr>
<tr class="separator:a1acaf1d891d81249161b026bfdc3217d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a0ccd3a3187b9e3460f8668a3ef9af"><td class="memItemLeft" align="right" valign="top"><a id="a08a0ccd3a3187b9e3460f8668a3ef9af" name="a08a0ccd3a3187b9e3460f8668a3ef9af"></a>
<a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>container</b></td></tr>
<tr class="separator:a08a0ccd3a3187b9e3460f8668a3ef9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An output through which actions flow. </p>
<p >Conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> specify which timing events are translated into actions. These actions have execution timestamps which determine when the action is to be executed, precise to the nanosecond.</p>
<p >More specialized versions of this interface provide the 'NewCondition' method to create conditions specific to the type of <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. For example, SoftwareActionSinks create conditions that emit signals to software. This interface captures the functionality common to all ActionSinks, such as atomic toggle, offset constraints, and introspection. In particular, ActionSinks have common failure modes.</p>
<p >Actions are queued for delivery at the appropriate time, in hardware. Hardware has limited storage, reflected by the Fill, Capacity, and MostFull properties. These should be monitored to ensure that the queue never overflows.</p>
<p >The first failure mode of an <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> is that the queue overflows. In this case, the hardware drops an action. Obviously, this is a critical error which may result in an undefined state. To prevent these failures, MostFull should be kept below some safety margin with respect to Capacity. Note: several distinct ActionSinks may share underlying hardware, and the Fill property is shared amongst all instances. Each overflow is recorded in the OverflowCount register. Due the rate at which this counter might increase, the API throttles updates using the SignalRate property.</p>
<p >Another critical error for an <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> is the possibility of a late action. This indicates that hardware was instructed to execute an action at a time in the past. This is typically caused by either a malfunctioning data master, desynchronized clocks, or conditions with large negative offsets. This is a critical failure as it might leave the system in an undefined state. Conditions may be configured to either drop or execute late actions. If late actions are dropped, a magnet might never be turned off. If late actions are executed, a magnet might be turned on again after it was supposed to be turned off (ie: the actions get misordered). In any case, LateCount is increased.</p>
<p >Similar to late actions, one can also have early actions. If an action is scheduled for execution too far into the future, the timing receiver will choose to mark it as early. This prevents these actions from permanently consuming space in the finite hardware buffers. Early actions are also critical failures as it can leave the system in an undefined state, just as a late action. Conditions may be configured to either drop or execute early actions.</p>
<p >The final misordering failure for an <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> is the possibilty of a Conflict. If two actions are scheduled to be executed at the same nanosecond, their relative order is undefined. These conflicts are a critical error as they may leave the system in an undefined state, just as with early and late actions. Conflicts should be prevented by never creating two Conditions on the same <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> which could occur at the same time. Note that it is NOT a Conflict for two actions to be executed at the same time by two different ActionSinks. For software, this means that two programs, each with their own <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> do not need to be concerned about conflicts between their schedules. As another example, two different LEMO output cables (corresponding to two OutputActionSinks) can be toggled high at the same time.</p>
<p >Finally, these is the possibility of a delayed action. Unlike late, early, and conflicting actions, delayed actions are never misordered. Thus, delayed actions are typically not as severe a failure mode, and Conditions default to allowing their execution. Delays can happen when the delivery rate of actions (potentially 1GHz) exceeds the capability of the receiver to process the actions. For example, an output might require 100ns to deliver an action. If two actions are scheduled for delivery back-to-back with 1ns between, the second action is delayed. For SoftwareActionSinks, delays can probably always be ignored because the handler is much much slower than the hardware. For a kicker, on the other hand, a delay is probably a critical error. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91a218439cdfc43e2adfc543254aa894" name="a91a218439cdfc43e2adfc543254aa894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a218439cdfc43e2adfc543254aa894">&#9670;&#160;</a></span>ActionSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">saftlib::ActionSink::ActionSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsaftlib_1_1ECA.html">ECA</a> &amp;&#160;</td>
          <td class="paramname"><em>eca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>action_sink_object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsaftbus_1_1Container.html">saftbus::Container</a> *&#160;</td>
          <td class="paramname"><em>container</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eca</td><td>points to the <a class="el" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns...">ECA</a> object on which the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> is created </td></tr>
    <tr><td class="paramname">name</td><td>name of the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> </td></tr>
    <tr><td class="paramname">channel</td><td>the <a class="el" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns...">ECA</a> channel that feeds the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> </td></tr>
    <tr><td class="paramname">num</td><td>subchannel of the <a class="el" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns...">ECA</a> channel</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new action sink on an <a class="el" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns...">ECA</a> device with a given name. If the name is an empty string, a name in the form "_&lt;number&gt;" will be generated. The <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> is attached to the given <a class="el" href="classsaftlib_1_1ECA.html" title="ECA (Event Condition Action) ECA is a hardwar unit cabable of executing actions at a given time (1 ns...">ECA</a> channel/subchannel. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ec200e16687ea6ddf5fcefb167b710b" name="a5ec200e16687ea6ddf5fcefb167b710b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec200e16687ea6ddf5fcefb167b710b">&#9670;&#160;</a></span>getActionCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getActionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions processed by the Sink. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions processed by the Sink.</dd></dl>
<p>As actions can be emitted very rapidly, ActionCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. <br  />
 </p>

</div>
</div>
<a id="a531fd07eb708e9b0f1d6ada36dcd241d" name="a531fd07eb708e9b0f1d6ada36dcd241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531fd07eb708e9b0f1d6ada36dcd241d">&#9670;&#160;</a></span>getActiveConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; saftlib::ActionSink::getActiveConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All active conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>All active conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.</dd></dl>
<p>All active conditions on the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. Each object path implements the the matching <a class="el" href="classsaftlib_1_1Condition.html" title="A rule matched against incoming events.">Condition</a> interface; for example, a <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> will have SoftwareConditions. </p>

</div>
</div>
<a id="ad64bc4d3793c224481a5ad9456f872c1" name="ad64bc4d3793c224481a5ad9456f872c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64bc4d3793c224481a5ad9456f872c1">&#9670;&#160;</a></span>getAllConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; saftlib::ActionSink::getAllConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>All conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.</dd></dl>
<p>All active and inactive conditions on the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. Each object path implements the the matching <a class="el" href="classsaftlib_1_1Condition.html" title="A rule matched against incoming events.">Condition</a> interface; for example, a <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> will have SoftwareConditions. </p>

</div>
</div>
<a id="a209a315d0ff908152b1f9b80b25e1ec5" name="a209a315d0ff908152b1f9b80b25e1ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209a315d0ff908152b1f9b80b25e1ec5">&#9670;&#160;</a></span>getCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t saftlib::ActionSink::getCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of actions queueable without Overflow. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of actions queueable without Overflow.</dd></dl>
<p>The timing receiver hardware can only queue a limited number of actions. This property reports the maximum number of actions that may be simultaneously queued. Be aware that this resource may be shared between multiple ActionSinks. For example, all SoftwareActionSinks share a common underlying queue in hardware. This Capacity represents the total size, which must be shared. </p>

</div>
</div>
<a id="aa46de5a53a6684af364093dff6ef4b07" name="aa46de5a53a6684af364093dff6ef4b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46de5a53a6684af364093dff6ef4b07">&#9670;&#160;</a></span>getConflictCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getConflictCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions which conflicted. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions which conflicted.</dd></dl>
<p>If two actions should have been executed simultaneously by the same <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>, they are executed in an undefined order. Each time this happens, the ConflictCount is increased. As conflicts can occur very rapidly, ConflictCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. </p>

</div>
</div>
<a id="aa2462d9b1ff9be4aaf2fa1fcdc2ed108" name="aa2462d9b1ff9be4aaf2fa1fcdc2ed108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2462d9b1ff9be4aaf2fa1fcdc2ed108">&#9670;&#160;</a></span>getDelayedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getDelayedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions which have been delayed. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions which have been delayed.</dd></dl>
<p>The timing receiver emits actions potentially every nanosecond. In the case that the receiver cannot immediately process an action, the timing receiver delays the action until the receiver is ready. This can happen either because the receiver was still busy with a previous action or the output was used externally (bus arbitration). As actions can be emitted very rapidly, DelayedCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. </p>

</div>
</div>
<a id="a834817f91ab96c29edd430688515702f" name="a834817f91ab96c29edd430688515702f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834817f91ab96c29edd430688515702f">&#9670;&#160;</a></span>getEarlyCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getEarlyCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions delivered early. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions delivered early.</dd></dl>
<p>As described in the interface overview, an action can be early due to a buggy data master, loss of clock synchronization, or very positive condition offsets. This is a critical failure as it can result in misordering of executed actions. Each such failure increases this counter. <br  />
</p>
<p >As early acitons can occur very rapidly, EarlyCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. </p>

</div>
</div>
<a id="ae3a9a3f0be3696893879c33fe9a837ce" name="ae3a9a3f0be3696893879c33fe9a837ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9a3f0be3696893879c33fe9a837ce">&#9670;&#160;</a></span>getEarlyThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getEarlyThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actions further into the future than this are early. </p>
<dl class="section return"><dt>Returns</dt><dd>Actions further into the future than this are early.</dd></dl>
<p>If an action is scheduled for execution too far into the future, it gets truncated to at most EarlyThreshold nanoseconds into the future. </p>

</div>
</div>
<a id="adfdbc979c119d797fc5f92be6a90f20e" name="adfdbc979c119d797fc5f92be6a90f20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdbc979c119d797fc5f92be6a90f20e">&#9670;&#160;</a></span>getInactiveConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; saftlib::ActionSink::getInactiveConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All inactive conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>All inactive conditions created on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>.</dd></dl>
<p>All inactive conditions on the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. Each object path implements the the matching <a class="el" href="classsaftlib_1_1Condition.html" title="A rule matched against incoming events.">Condition</a> interface; for example, a <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> will have SoftwareConditions. </p>

</div>
</div>
<a id="a7feb6dfc8976ac410f9d0149d65e7c4a" name="a7feb6dfc8976ac410f9d0149d65e7c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feb6dfc8976ac410f9d0149d65e7c4a">&#9670;&#160;</a></span>getLateCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getLateCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions delivered late. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions delivered late.</dd></dl>
<p>As described in the interface overview, an action can be late due to a buggy data master, loss of clock synchronization, or very negative condition offsets. This is a critical failure as it can result in misordering of executed actions. Each such failure increases this counter. <br  />
</p>
<p >As late actions can occur very rapidly, LateCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. <br  />
 </p>

</div>
</div>
<a id="a268d9a4ff28151bfdcdec95d77d8b649" name="a268d9a4ff28151bfdcdec95d77d8b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268d9a4ff28151bfdcdec95d77d8b649">&#9670;&#160;</a></span>getLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getLatency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nanoseconds between event and earliest execution of an action. </p>
<dl class="section return"><dt>Returns</dt><dd>Nanoseconds between event and earliest execution of an action. </dd></dl>

</div>
</div>
<a id="a968da9e51228e652c1dcb704e43a1c10" name="a968da9e51228e652c1dcb704e43a1c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968da9e51228e652c1dcb704e43a1c10">&#9670;&#160;</a></span>getMaxOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t saftlib::ActionSink::getMaxOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum allowed offset (nanoseconds) usable in NewCondition. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum allowed offset (nanoseconds) usable in NewCondition.</dd></dl>
<p>Large offsets are almost always an error. A large positive offset could result in early actions being created. By default, no condition may have an offset larger than 1s. Attempts to create conditions with offsets greater than MaxOffset result in an error. Change this property to override this safety feature. </p>

</div>
</div>
<a id="af5b3c553a6ce7103e4a032775ec01436" name="af5b3c553a6ce7103e4a032775ec01436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b3c553a6ce7103e4a032775ec01436">&#9670;&#160;</a></span>getMinOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t saftlib::ActionSink::getMinOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum allowed offset (nanoseconds) usable in NewCondition. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum allowed offset (nanoseconds) usable in NewCondition.</dd></dl>
<p>Large offsets are almost always an error. A very negative offset could result in Late actions. By default, no condition may be created with an offset smaller than -100us. Attempts to create conditions with offsets less than MinOffset result in an error. Change this property to override this safety feature. </p>

</div>
</div>
<a id="a91841b67ca1f4a683aac1b847ef91d60" name="a91841b67ca1f4a683aac1b847ef91d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91841b67ca1f4a683aac1b847ef91d60">&#9670;&#160;</a></span>getMostFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t saftlib::ActionSink::getMostFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the largest number of pending actions seen. </p>
<dl class="section return"><dt>Returns</dt><dd>Report the largest number of pending actions seen.</dd></dl>
<p>The timing receiver hardware can only queue a limited number of actions. This property reports the highest Fill level seen by the hardware since it was last reset to 0. Keep in mind that the queue may be shared, including actions from all users of the underlying hardware. So two programs each using a <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> will potentially see an increase in this value when both programs are active. </p>

</div>
</div>
<a id="a1e65092d2ad770c9d2c97bd510af4069" name="a1e65092d2ad770c9d2c97bd510af4069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e65092d2ad770c9d2c97bd510af4069">&#9670;&#160;</a></span>getOverflowCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getOverflowCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of actions lost due to Overflow. </p>
<p >The underlying hardware queue may overflow once Fill=Capacity. This is a critical error condition that must be handlded. The causes may be either: 1- the actions have an execution time far enough in the future that too many actions are buffered before they are executed, or 2- the receiving component is unable to execute actions as quickly as the timing system delivers them. The second case is particularly likely for SoftwareActionSinks that attempt to listen to high frequency events. Even though SoftwareActionSinks share a common queue, Overflow is reported only to the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> whose action was dropped. As overflows can occur very rapidly, OverflowCount may increase by more than 1 between emissions. There is a minimum delay of SignalRate nanoseconds between updates to this property. </p>

</div>
</div>
<a id="a4986fd88c94fa4fb769ce879c24482fa" name="a4986fd88c94fa4fb769ce879c24482fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4986fd88c94fa4fb769ce879c24482fa">&#9670;&#160;</a></span>getSignalRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t saftlib::ActionSink::getSignalRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum interval between updates (nanoseconds, default 100ms). </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum interval between updates (nanoseconds, default 100ms).</dd></dl>
<p>The properties OverflowCount, ActionCount, LateCount, EarlyCount, ConflictCount, and DelayedCount can increase rapidly. To prevent excessive CPU load, SignalRate imposes a minimum cooldown between updates to these values. </p>

</div>
</div>
<a id="a2058baeebb6fcea54becfd3c6e1f650a" name="a2058baeebb6fcea54becfd3c6e1f650a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2058baeebb6fcea54becfd3c6e1f650a">&#9670;&#160;</a></span>ReadFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t saftlib::ActionSink::ReadFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the number of currently pending actions. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of pending actions.</dd></dl>
<p>The timing receiver hardware can only queue a limited number of actions. This method reports the current number of queued actions, which includes actions from all users of the underlying hardware. So two programs each using a <a class="el" href="classsaftlib_1_1SoftwareActionSink.html" title="An output through which software actions flow.">SoftwareActionSink</a> will potentially see an increase in this value when both programs are active. Also, this value can change very rapidly and is thus changes are not signalled. Polling it is likely to miss short fluctuations. See MostFull for a better approach to monitoring. </p>

</div>
</div>
<a id="ac3596e1d3db031efb531a49648fe524f" name="ac3596e1d3db031efb531a49648fe524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3596e1d3db031efb531a49648fe524f">&#9670;&#160;</a></span>ToggleActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saftlib::ActionSink::ToggleActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically toggle the active status of conditions. </p>
<p >When reconfiguring an <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>, it is sometimes necessary to apply many changes simultaneously. To achieve this, simply use NewCondition to create all the new conditions in the inactive state. Then use this method to simultaneous toggle all conditions on this <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. The new active conditions will be applied such that on one nanosecond, the old set is active and on the next nanosecond the new set is active. Be aware that this function can be used by different applications and it can therefore influence other applications that did not explicitely <a class="el" href="classsaftlib_1_1Owned.html#a12fee085da8848580430315c096b97a9" title="Claim ownership of the object.">Own()</a> the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a>. To avoid this, always own the <a class="el" href="classsaftlib_1_1ActionSink.html" title="An output through which actions flow.">ActionSink</a> before using it. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsaftlib_1_1ActionSink_ac3596e1d3db031efb531a49648fe524f_cgraph.png" border="0" usemap="#aclasssaftlib_1_1ActionSink_ac3596e1d3db031efb531a49648fe524f_cgraph" alt=""/></div>
<map name="aclasssaftlib_1_1ActionSink_ac3596e1d3db031efb531a49648fe524f_cgraph" id="aclasssaftlib_1_1ActionSink_ac3596e1d3db031efb531a49648fe524f_cgraph">
<area shape="rect" title="Atomically toggle the active status of conditions." alt="" coords="5,5,132,45"/>
<area shape="rect" href="classsaftlib_1_1Owned.html#aed5da441e1295bf94b4b327e8a9445c2" title="Throw an exception if the caller is not the owner." alt="" coords="180,13,351,38"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a540ccc530877c27b128c85aedd22df5b" name="a540ccc530877c27b128c85aedd22df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540ccc530877c27b128c85aedd22df5b">&#9670;&#160;</a></span>SigConflict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, uint64_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>&gt; saftlib::ActionSink::SigConflict</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An example of a conflict since last ConflictCount change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new value of ConflictCount when this signal was raised. </td></tr>
    <tr><td class="paramname">event</td><td>The event identifier of a conflicting action. </td></tr>
    <tr><td class="paramname">param</td><td>The parameter field, whose meaning depends on the event ID. </td></tr>
    <tr><td class="paramname">deadline</td><td>The scheduled action execution timestamp (event time + offset). </td></tr>
    <tr><td class="paramname">executed</td><td>The timestamp when the action was actually executed. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b3e60a608f736de640575408e85538" name="a07b3e60a608f736de640575408e85538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b3e60a608f736de640575408e85538">&#9670;&#160;</a></span>SigDelayed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, uint64_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a> &gt; saftlib::ActionSink::SigDelayed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An example of a delayed action the last DelayedCount change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The value of DelayedCount when this signal was raised. </td></tr>
    <tr><td class="paramname">event</td><td>The event identifier of the delayed action. </td></tr>
    <tr><td class="paramname">param</td><td>The parameter field, whose meaning depends on the event ID. </td></tr>
    <tr><td class="paramname">deadline</td><td>The desired execution timestamp (event time + offset). </td></tr>
    <tr><td class="paramname">executed</td><td>The timestamp when the action was actually executed. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a394db701a5f5b62b33a9f00025875e64" name="a394db701a5f5b62b33a9f00025875e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394db701a5f5b62b33a9f00025875e64">&#9670;&#160;</a></span>SigEarly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, uint32_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>&gt; saftlib::ActionSink::SigEarly</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An example of an early action since last EarlyCount change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new value of LateCount when this signal was raised. </td></tr>
    <tr><td class="paramname">event</td><td>The event identifier of the early action. </td></tr>
    <tr><td class="paramname">param</td><td>The parameter field, whose meaning depends on the event ID. </td></tr>
    <tr><td class="paramname">deadline</td><td>The desired execution timestamp (event time + offset). </td></tr>
    <tr><td class="paramname">executed</td><td>The actual execution timestamp. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa92fc752cdc979fca68f12d9db69361" name="aaa92fc752cdc979fca68f12d9db69361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa92fc752cdc979fca68f12d9db69361">&#9670;&#160;</a></span>SigLate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, uint32_t, uint64_t, uint64_t, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>, <a class="el" href="classsaftlib_1_1Time.html">saftlib::Time</a>&gt; saftlib::ActionSink::SigLate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: An example of a late action since last LateCount change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new value of LateCount when this signal was raised. </td></tr>
    <tr><td class="paramname">event</td><td>The event identifier of the late action. </td></tr>
    <tr><td class="paramname">param</td><td>The parameter field, whose meaning depends on the event ID. </td></tr>
    <tr><td class="paramname">deadline</td><td>The desired execution timestamp (event time + offset). </td></tr>
    <tr><td class="paramname">executed</td><td>The actual execution timestamp. Keep in mind that an action is only counted as late if it is scheduled for the past. An action which leaves the timing receiver after its deadline, due to a slow consumer, is a delayed (not late) action. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="ActionSink_8hpp_source.html">ActionSink.hpp</a></li>
<li>src/ActionSink.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
