<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Saftlib Simplified API for Timing: Saftbus: an interprocess communication library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Saftlib Simplified API for Timing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Saftbus: an interprocess communication library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Features</h1>
<ul>
<li>A program <a href="saftbusd-noda.cpp">saftbusd</a> that can be run in the background (daemon) and provides services which can be accessed through a UNIX domain socket by Proxy objects.</li>
<li>New services can be added by loading plugins at startup or during runtime of the daemon</li>
<li>A code generator that facilitates developments of plugins for the daemon</li>
<li>A command line tool <a href="saftbus-ctl.cpp">saftbus-ctl</a> to control the daemon, e.g. load/unload new plugins or remove service objects</li>
<li>A deterministic memory allocator for real time applications</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Architecture overview</h1>
<p ><img src="saftbus.png" alt="saftbus architecture overview" class="inline"/></p>
<p >A server process provides an inter process communication (IPC) channel (a UNIX domain socket) over which client processes can connect. At startup or at runtime, shared objects can be loaded by the server (plugins). These plugins contain C++ classes (driver classes) that are supposed to be shared resources, an should be accessible by all connected client processes. The plugins also contain automatically generated Service and Proxy classes with boilerplate code for the IPC data transfer. Instances of the Service classes are managed by the server. Client programs use instances of Proxy classes to access methods, properties, and signals provided by the driver classes.</p>
<p >The program <a href="saftbusd-noda.cpp">saftbusd</a> is a simple implementation of such a server and is installed together with the saftbus library. It is also possible to develop a different server by using saftbus library components. The program saftbus-gen can be used to generate the Proxy and Service classes from a given driver class declaration. Driver classes are ordinary C++ classes.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
History</h1>
<p >saftlib was originally written with <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> for inter process communication. D-Bus was later replaced with a more real-time friendly system called saftbus. Initially, the saftbus API was identical to the D-Bus API (<a href="https://developer-old.gnome.org/glibmm/stable/namespaceGio_1_1DBus.html">Gio::Dbus</a>) to avoid code changes in the rest of saftlib. Now, saftbus is re-written from scratch with a new API, and the rest of saftlib was changed to work with the new API. The re-written version of saftbus still shares some properties with D-Bus:</p><ul>
<li>A daemon running in the background maintains a list of available services.</li>
<li>Services offer an interface which consists of functions, properties (setter/getter functions), and signals.</li>
<li>Multiple processes can share services and use the provided interface.</li>
</ul>
<p >Many aspects are different from D-Bus. The most important being:</p><ul>
<li>Services cannot be added by processes connecting to the daemon but have to be added by dynamically loading a plugin (shared library) into the daemon.</li>
<li>Services are only usable if the signature of the interface is known. Introspection is not possible.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Environment variables</h1>
<ul>
<li><code>SAFTBUS_SOCKET_PATH</code> : determines the location of the UNIX domain socket in the file system. Default ist <code>/var/run/saftbus/saftbus</code></li>
<li><code>SAFTD_ALLOCATOR_CONFIG</code> : set the configuration of the deterministic memory allocator. Default value is "16384.128 1024.1024 64.16384" (see below for the meaning of the numbers)</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
Startup</h1>
<p >Run the saftbusd executable. In case of an error such as <code>cannot create socket directory: /var/run/saftbus</code>, try to run with root privileges or set the <code>SAFTBUS_SOCKET_PATH</code> environment variable to a location where the socket can be created (e.g. <code>/tmp/saftbus</code>) If saftbusd was run without arguments, there will be no services apart from the <a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a>. Additional services can be added by loading saftbus-plugins, e.g <code>saftbus-ctl -l libsaftd-service.so tr0:dev/wbm0</code>. Alternatively, plugins can be loaded at startup by passing them as command line arguments to the saftbusd executable (e.g. <code>saftbusd libsaftd-service.so tr0:dev/wbm0</code>).</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Deterministic memory allocator</h2>
<p >Three versions of the saftbusd binary are distributed:</p><ul>
<li><code>saftbusd</code> contains a configurable deterministic global memory allocator. It manages memory blocks of a given size and given number. The number of blocks and their size can be configured using the SAFTD_ALLOCATOR_CONFIG environment variable. The default configuration is "16384.128 1024.1024 64.16384" which means<ul>
<li>16384 blocks of size 128 bytes</li>
<li>1024 blocks of size 1024 bytes</li>
<li>64 blocks of size 16384 bytes Allocations larger than the larges block size fall back to the default heap allocator. Number of blocks must strictly decrease. block size must strictly increase. This is intended for real time critical applications.</li>
</ul>
</li>
<li><code>saftbusd-srta</code> contains a simpler non-configurable deterministic memory allocator with hard coded block sizes.</li>
<li><code>saftbusd-norta</code> uses standard heap allocations</li>
</ul>
<p >Details on the allocator implementation are described here</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Saftbus plugins</h1>
<p >Typical use case is to run saftbusd and load a custom plugin to provide custom services, and use custom programs that communicate with the services provided by the plugin using proxy classes. See below for a simple example. </p>
<h2><a class="anchor" id="autotoc_md8"></a>
Services</h2>
<ul>
<li>A saftbus service encapsulates an instance of a driver class.</li>
<li>It handles the inter process communication data and translates it into function calls that are redirected to the driver instance. The result is sent back to the calling process.</li>
<li>All services are managed by the <a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a> class, using a unique string called "object path".</li>
<li>Calling <code>saftbus-ctl -s</code> list all managed services on the <code><a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a></code>.</li>
<li>The source code of the service class is (typically) generated from a Driver class using the <code>saftbus-gen</code> tool, which extracts the signatures of all annotated methods and signals.</li>
<li>An instance of a service class needs to be constructed with a pointer to an instance of the corresponding driver class from which it was generated. </li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Driver classes</h2>
<ul>
<li>Are normal C++ classes, there are no restrictions on how a driver class can be written.</li>
<li>Must not be defined in the global scope (<code>saftbus-gen</code> doesn't support this yet).</li>
<li>Inheritance is explicitly allowed.</li>
<li>Methods and signals of the driver class which are supposed to be usable from different processes (through a Proxy object) need to be annotated with the <code>// @saftbus-export</code> comment. </li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Proxy classes</h2>
<ul>
<li>Are generated from the definition of the Driver class, just like Service classes.</li>
<li>Have all methods and signals that were annotated with the <code>// @saftbus-export</code> comment in the Driver class.</li>
<li>Proxy objects (instances of Proxy classes) can be used in any program to access the corresponding Service through saftbus.</li>
<li>Proxy classes are constructed using the object path of the service in the <code><a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a></code>.</li>
<li>Multiple Proxy instances can share the same Service instance.</li>
<li>If a Service emits a signal, all Proxy instances will receive it. </li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Entry function</h2>
<ul>
<li>Each plugin needs an export "C" function with name <code>create_services</code>.</li>
<li>The function receives a pointer to a <code><a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a></code> and a vector of strings (arguments).</li>
<li>It can add service objects to the container by providing an object path and a unique_ptr of the Service class.</li>
<li>The Memory of the Driver class must be managed by the <code>create_services</code> function</li>
<li>A destruction callback can be registered with the service object, which gets called if the service is removed from the <code><a class="el" href="classsaftbus_1_1Container.html" title="A Container of Service objects.">saftbus::Container</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
A very simple example plugin (examples/ex00)</h2>
<h3><a class="anchor" id="autotoc_md13"></a>
Driver class</h3>
<p >The driver class has a random number generator for integers in the range [1..6]. It is called "Dice". Dice_Proxies can create a random number using the method "Throw". The result is communicated using the signal "Result". All Dice_Proxies with a connected callback function will be notified when a new number was generated. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#ifndef EX00_DICE_HPP</div>
<div class="line">#define EX00_DICE_HPP</div>
<div class="line">#include &lt;sigc++/sigc++.h&gt;</div>
<div class="line">#include &lt;functional&gt;</div>
<div class="line">namespace ex00 {</div>
<div class="line">  class Dice {</div>
<div class="line">  public:</div>
<div class="line">    // @saftbus-export</div>
<div class="line">    void Throw();</div>
<div class="line">    // @saftbus-export</div>
<div class="line">    sigc::signal&lt;void, int&gt; SigResult;</div>
<div class="line">    // @saftbus-export</div>
<div class="line">    std::function&lt;void(int result)&gt; FunResult;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">#endif</div>
</div><!-- fragment --><p> The definition of the Throw method is in Dice.cpp: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &quot;Dice.hpp&quot;</div>
<div class="line">#include &lt;cstdlib&gt;</div>
<div class="line">namespace ex00 {</div>
<div class="line">  void Dice::Throw() {</div>
<div class="line">    int number = rand()%6+1;</div>
<div class="line">    SigResult.emit(number);</div>
<div class="line">    FunResult(number);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Four source files (Dice_Service.hpp, Dice_Service.cpp, Dice_Proxy.hpp, Dice_Proxy.cpp) will be generated with the following call to the <code>saftbus-gen</code> tool: </p><pre class="fragment">saftbus-gen Dice.hpp
</pre><p> The method <code>Dice::Throw</code> and the signals <code>SigResult</code> and <code>FunResult</code> will be identified by <code>saftbus-gen</code> and are added to the Dice_Proxy interface. </p>
<h3><a class="anchor" id="autotoc_md14"></a>
Entry point for the plugin</h3>
<p >The file <code>create_services.cpp</code> contains the <code>create_services</code> function, which is called when the plugin is loaded by saftbusd. In this case, one argument is expected which specifies the object path of the created Dice_Service instance. Optionally, a destruction callback can be attached to the Service. This is called whenever the service is removed, (e.g. someone calling <code>saftbus-ctl -r &lt;object-path&gt;</code>). In this case the Driver instance is destroyed by the callback function so that the plugin can be safely removed (<code>saftbus-ctl -u libsaftbus-ex00-service.lo</code>). If the plugin is removed when there are still active services created by it, the result will be a crash of saftbusd. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &quot;Dice.hpp&quot;</div>
<div class="line">#include &quot;Dice_Service.hpp&quot;</div>
<div class="line">#include &lt;saftbus/error.hpp&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;ex00::Dice&gt; dice;</div>
<div class="line"> </div>
<div class="line">void destroy_callback() {</div>
<div class="line">  dice.reset();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extern &quot;C&quot; </div>
<div class="line">void create_services(saftbus::Container *container, const std::vector&lt;std::string&gt; &amp;args) {</div>
<div class="line">  if (args.size() == 1 &amp;&amp; !dice) {</div>
<div class="line">    dice = std::unique_ptr&lt;ex00::Dice&gt;(new ex00::Dice);</div>
<div class="line">    container-&gt;create_object(args[0], </div>
<div class="line">      std::unique_ptr&lt;ex00::Dice_Service&gt;(new ex00::Dice_Service(dice.get(), destroy_callback))</div>
<div class="line">    );</div>
<div class="line">  } else {</div>
<div class="line">    throw saftbus::Error(saftbus::Error::INVALID_ARGS, &quot;need object path as argument&quot;);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> All Service classes and the create_services function are compiled into a share library (the plugin that will be loaded by saftbusd) All Proxy classes are compiled into another library that other programs can use to create Proxy objects to utilize the Service objects in saftbusd. </p>
<h3><a class="anchor" id="autotoc_md15"></a>
Utilize the Driver_Proxy</h3>
<p >Programs instantiate a Dice_Proxy object and use it in the very same way as an instance of the Dice driver class would be used. A program which can be used for both, listen to Result as well as initiate a Throw, could look like this: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &quot;Dice_Proxy.hpp&quot;</div>
<div class="line">#include &lt;saftbus/client.hpp&gt;</div>
<div class="line">#include &lt;sigc++/sigc++.h&gt; </div>
<div class="line">#include &lt;functional&gt; </div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">std::string cmd, object_path;</div>
<div class="line">void print_result_sig(int result) {</div>
<div class="line">  std::cout &lt;&lt; &quot;dice &quot; &lt;&lt; object_path &lt;&lt; &quot; was thrown. SigResult = &quot; &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">void print_result_fun(int result) {</div>
<div class="line">  std::cout &lt;&lt; &quot;dice &quot; &lt;&lt; object_path &lt;&lt; &quot; was thrown. FunResult = &quot; &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">int main(int argc, char *argv[]) {</div>
<div class="line">  if (argc != 3) {</div>
<div class="line">    std::cout &lt;&lt; &quot;usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;object-path&gt; throw|listen&quot; &lt;&lt; std::endl;</div>
<div class="line">    return 1;</div>
<div class="line">  }</div>
<div class="line">  object_path = argv[1];</div>
<div class="line">  cmd         = argv[2];</div>
<div class="line"> </div>
<div class="line">  auto dice = ex00::Dice_Proxy::create(object_path);</div>
<div class="line"> </div>
<div class="line">  dice-&gt;SigResult.connect(sigc::ptr_fun(print_result_sig));</div>
<div class="line">  dice-&gt;FunResult = &amp;print_result_fun;</div>
<div class="line">  if (cmd == &quot;throw&quot;) {</div>
<div class="line">    dice-&gt;Throw();</div>
<div class="line">  }</div>
<div class="line">  for (;;) {</div>
<div class="line">    saftbus::SignalGroup::get_global().wait_for_signal();</div>
<div class="line">    if (cmd != &quot;listen&quot;) break;</div>
<div class="line">  }</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >After launching the saftbusd with the newly created library as argument arguments of the ceate_services function must appear directly behind the shared object filename </p><pre class="fragment">$ saftbusd libex00-service.so /my/dice
</pre><p> A call to <code>saftbus-ctl -s</code> should show the newly created Dice under the <code>/my/dice</code> object path, next to the Container interface under <code>/saftbus</code>: All plugin shared object files and all connected client processes are listed as well: </p><div class="fragment"><div class="line">$ saftbus-ctl -s</div>
<div class="line">objects:</div>
<div class="line">  object-path ID [owner] sig-fd/use-count interface-names</div>
<div class="line">  /saftbus 1 [-1]  6/1 Container </div>
<div class="line">  /my/dice 2 [-1]  Dice </div>
<div class="line"> </div>
<div class="line">active plugins: </div>
<div class="line">  libsaftbus-ex00-service.so</div>
<div class="line"> </div>
<div class="line">connected client processes:</div>
<div class="line">  5 (pid=284490)</div>
<div class="line">$</div>
</div><!-- fragment --><p> A dice throw can be initiated by calling </p><div class="fragment"><div class="line">$ ex00-ctl /my/dice throw</div>
<div class="line">dice /my/dice was thrown. Result = 5</div>
<div class="line">$ ex00-ctl /my/dice throw</div>
<div class="line">dice /my/dice was thrown. Result = 4</div>
<div class="line">$ ex00-ctl /my/dice throw</div>
<div class="line">dice /my/dice was thrown. Result = 1</div>
<div class="line">$</div>
</div><!-- fragment --><p> If other instances of ex00-ctl were launched before with the "/my/dice listen" arguments, they all would show the following: </p><div class="fragment"><div class="line">$ ex00-ctl /my/dice listen</div>
<div class="line">dice /my/dice was thrown. Result = 5</div>
<div class="line">dice /my/dice was thrown. Result = 4</div>
<div class="line">dice /my/dice was thrown. Result = 1</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md16"></a>
General rules for drivers and services</h2>
<ul>
<li>if a driver class <code>Parent</code> is used as a saftbus service and manges other driver classes of type <code>Child</code> that are also used as saftbus services, the destructor of Parent must destroy the Child objects before removing the Child services. This is important because destructors of child objects may send signals to clients and that is only possible if the service object still exists.</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Further information</h2>
<p >A More complex examples which make use of inheritance and creation of nested services can be found under</p><ul>
<li>examples/ex01_dice.</li>
<li>examples/ex02_dice_cup.</li>
<li>the saftlib plugin saftlib</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Allocator implementation</h2>
<p >Each allocator manages a fixed number of fixed size memory blocks and a stack. Each stack position refers to a block and each block refers back to that stack position. Allocations return the block where the last free stack position points to (runtime is O(1)). A free operation can happen on any block, therefore pointers have to be swapped in order to remove the gaps in the stack (runtime is still O(1): always four indirections and two swap operations) The following picture explains how it works (green is free, red is allocated).</p>
<p ><img src="allocator.png" alt="saftbus architecture overview" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
