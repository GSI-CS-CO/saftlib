/** Copyright (C) 2011-2016 GSI Helmholtz Centre for Heavy Ion Research GmbH
 *
 *  @author Wesley W. Terpstra <w.terpstra@gsi.de>
 *
 *******************************************************************************
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *******************************************************************************
 */
/* Synopsis */
/* ==================================================================================================== */
/* Burst control application */

/* Defines */
/* ==================================================================================================== */
#define __STDC_FORMAT_MACROS
#define __STDC_CONSTANT_MACROS
#define ECA_EVENT_ID_LATCH     UINT64_C(0xfffe000000000000) /* FID=MAX & GRPID=MAX-1 */
#define ECA_EVENT_MASK_LATCH   UINT64_C(0xfffe000000000000)
#define ECA_EVENT_MASK         UINT64_C(0xffffffffffffffff) /* mask for all events */
#define IO_CONDITION_OFFSET    5000

#define BG_BURST_PERIOD        INTERVAL_200US               /* burst period that can be repeatedly generated by LM32, nanoseconds */

/* Includes */
/* ==================================================================================================== */
#include <iostream>
#include <iomanip>
#include <time.h>
#include <sys/time.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <string>
#include <unistd.h>
#include <algorithm>
#include <cstring>
#include <cctype> // isspace, isalpha

#include "interfaces/SAFTd.h"
#include "interfaces/TimingReceiver.h"
#include "interfaces/SoftwareActionSink.h"
#include "interfaces/SoftwareCondition.h"
#include "interfaces/iDevice.h"
#include "interfaces/Output.h"
#include "interfaces/Input.h"
#include "interfaces/OutputCondition.h"
#include "interfaces/EmbeddedCPUActionSink.h"
#include "interfaces/EmbeddedCPUCondition.h"
#include "interfaces/BurstGenerator.h"

#include "CommonFunctions.h"

#include "drivers/eca_flags.h"
#include "drivers/io_control_regs.h"
#include "drivers/bg_regs.h"

/* Namespace */
/* ==================================================================================================== */
using namespace saftlib;
using namespace std;

/* Global */
/* ==================================================================================================== */
const char*    program      = NULL;  /* Name of the application */
const char*    deviceName   = NULL;  /* Name of the device */
char*          pEnd         = NULL;  /* Arguments parsing */
vector<string> bg_options;           /* Command options */
int            opt          = 0;     /* Number of given options */
string         optFileName  = "";    /* Option file name */
char           opt_buf[4096];        /* Option buffer */
shared_ptr<TimingReceiver_Proxy> tr = NULL; /* Proxy for the target timing receiver */
map<string, string> outs;         /* Outputs */
map<string, string> ins;          /* Inputs */
map<string, string> bg_iface;     /* BurstGenerator interface of the target timing receiver */
shared_ptr<BurstGenerator_Proxy> bg = NULL; /* Proxy for the burst generator */
shared_ptr<EmbeddedCPUActionSink_Proxy> ecpu = NULL; /* Proxy for the eCPU action channel */

const char*    ioName       = NULL;  /* Name of the IO */
bool           ioNameGiven  = false; /* IO name given? */
bool           ioNameExists = false; /* IO name does exist? */
bool           UTC          = false; /* use UTC instead of TAI */
map<string, uint64_t> map_PrefixName;       /* Translation table IO name <> prefix */
int            io_oe        = 0;     /* Output enable */
int            io_term      = 0;     /* Input Termination */
int            io_spec_out  = 0;     /* Special (output) function */
int            io_spec_in   = 0;     /* Special (input) function */
int            io_gate_out  = 0;     /* Output gate */
int            io_gate_in   = 0;     /* Input gate */
int            io_mux       = 0;     /* Gate (BuTiS) */
int            io_pps       = 0;     /* Gate (PPS) */
int            io_drive     = 0;     /* Drive IO value */
int            ioc_flip     = 0;     /* Flip active bit for all conditions */
int            s_time       = 0;     /* Stable time to set */
uint64_t       eventID      = 0x0;   /* Event ID (new condition) */
uint64_t       eventMask    = 0x0;   /* Event mask (new condition) */
int64_t        offset       = 0x0;   /* Event offset (new condition) */
uint64_t       flags        = 0x0;   /* Accept flags (new condition) */
int64_t        level        = 0x0;   /* Rising or falling edge (new condition) */
uint64_t       prefix       = 0x0;   /* IO input prefix */
bool           translate_mask = false; /* Translate mask? */
bool           negative     = false; /* Offset negative? */
bool           ioc_valid    = false; /* Create arguments valid? */
bool           set_oe       = false; /* Set? */
bool           set_term     = false; /* Set? */
bool           set_spec_in  = false; /* Set? */
bool           set_spec_out = false; /* Set? */
bool           set_gate_in  = false; /* Set? */
bool           set_gate_out = false; /* Set? */
bool           set_mux      = false; /* Set? (BuTiS gate) */
bool           set_pps      = false; /* Set? (PPS gate) */
bool           set_drive    = false; /* Set? */
bool           set_stime    = false; /* Set? (Stable time) */
bool           ios_snoop    = false; /* Snoop on an input(s) */
bool           ios_wipe     = false; /* Wipe/disable all events from input(s) */
bool           ios_i_to_e   = false; /* List input to event table */
bool           ios_setup_only = false; /* Only setup input to event */
bool           ioc_create   = false; /* Create condition */
bool           ioc_disown   = false; /* Disown created condition */
bool           ioc_destroy  = false; /* Destroy condition */
bool           ioc_list     = false; /* List conditions */
bool           ioc_dis_ios  = false; /* Disable event source? */
bool           verbose_mode = false; /* Print verbose output to output stream => -v */
bool           show_help    = false; /* Print help => -h */
bool           show_table   = false; /* Print io mapping table => -i */

int            burstId         = 0;     /* burst ID */
bool           burstIdGiven    = false; /* is burst ID given? */
uint64_t       bg_start_e_id   = 0x00;  /* Start event ID */
uint64_t       bg_start_e_mask = ECA_EVENT_MASK;  /* Start event mask */
uint64_t       bg_stop_e_id    = 0x00;  /* Stop event ID */
uint64_t       bg_stop_e_mask  = ECA_EVENT_MASK;  /* Stop event mask */
uint32_t       bg_t_high       = 0x00;  /* Signal active state length, t_high */
uint32_t       bg_t_p          = 0x00;  /* Signal period, t_p */
int64_t        bg_t_b          = 0x00;  /* Burst period, t_b (=0 endless) */
uint64_t       bg_b_delay      = 0x00;  /* Burst delay, b_d, nanoseconds */
uint32_t       bg_b_flag       = 0x00;  /* Burst flag, b_f, (=0 new/overwrite, =1 append) */
int            bg_disen        = 0;     /* Disable or enable option argument value */
vector<string> bg_instr_args;           /* Arguments of instruct option */
int            bg_id           = 0x00;  /* Burst ID */
bool           bg_fw_id        = false; /* Get and print the firmware id of the burst generator */
bool           bg_instr        = false; /* Demo option to test the instruct method call */
bool           bg_cfg_io       = false; /* Set the ECA conditions for IO actions */
bool           bg_clr_all      = false; /* Clear all unowned conditions for the IO and eCPU actions */
bool           bg_ls_bursts    = false; /* List enabled bursts */
bool           bg_disen_burst  = false; /* Disable or enable burst, id */
bool           bg_mk_burst     = false; /* Create new burst */
bool           bg_rm_burst     = false; /* Remove burst */

/* Prototypes */
/* ==================================================================================================== */
static void io_help        (void);
static int  io_setup       (int io_oe, int io_term, int io_spec_out, int io_spec_in, int io_gate_out, int io_gate_in, int io_mux, int io_pps, int io_drive, int s_time,
                            bool set_oe, bool set_term, bool set_spec_out, bool set_spec_in, bool set_gate_out, bool set_gate_in, bool set_mux, bool set_pps, bool set_drive, bool set_stime,
                            bool verbose_mode);
static int  io_create      (bool disown, uint64_t eventID, uint64_t eventMask, int64_t offset, uint64_t flags, int64_t level, bool offset_negative, bool translate_mask);
static int  io_destroy     (bool verbose_mode);
static int  io_flip        (bool verbose_mode);
static int  io_list        (void);
static int  io_list_i_to_e (void);
static int  io_print_table (bool verbose_mode);
static void io_catch_input (uint64_t event, uint64_t param, saftlib::Time deadline, saftlib::Time executed, uint16_t flags);
static int  io_snoop       (bool mode, bool setup_only, bool disable_source, uint64_t prefix_custom);

static int  bg_get_fw_id        (void);
static int  bg_instruct         (std::vector<std::string> instr);
static int  bg_config_io        (uint32_t t_high, uint32_t t_period, int64_t t_burst, uint64_t b_delay, uint32_t b_flag, bool verbose_mode);
static int  bg_get_io_name      (int burst_id, std::string &name);
static int  bg_list_bursts      (int burst_id, bool verbose);
static int  bg_remove_burst     (int burst_id, bool verbose);
static int  bg_disenable_burst  (int burst_id, int disen, bool verbose);
static int  bg_create_burst     (int burst_id, uint64_t e_id, uint64_t e_mask, uint64_t stop_e_id, uint64_t stop_e_mask, bool verbose);
static std::string find_io_name (std::shared_ptr<TimingReceiver_Proxy> tr, std::vector<uint32_t> info);
static int  ecpu_update         (uint64_t e_id, uint64_t e_mask, int64_t offset, uint32_t tag, bool verbose);
static int  ecpu_check          (uint64_t e_id, uint64_t e_mask, int64_t offset, uint32_t tag);
static int  ecpu_destroy        (bool verbose_mode);
static int  bg_clear_all        (bool verbose);
static void bg_help             (char option);
static int  bg_invoke_async     (std::shared_ptr<BurstGenerator_Proxy> bg, uint32_t inst_code, std::vector<uint32_t> inst_args);
static bool bg_is_comment       (const std::string& str);
//static std::vector<std::string> bg_extract_options(const std::string& str, const std::string& rule);
static int parse_options        (int optc, char* optv[], const char* optstr);
static int bg_parse_options     (const std::string& options, const char* optstring);
static int bg_check_arguments   (void);
static void bg_reset_variables  (void);
static int bg_do_configuration  (void);
static int bg_setup_device      (const char* device_name);
static int io_check             (uint64_t e_id, bool &found);
static void print_burst_info    (std::vector<uint32_t> info);

/* Set up a timing receiver */
static int bg_setup_device(const char* device_name)
{
  map<string, string> devices = SAFTd_Proxy::create()->getDevices();
  if (devices.find(device_name) == devices.end())
  {
    cerr << "Error: device " << device_name << " does not exist!" << endl;
    return -1;
  }

  tr = TimingReceiver_Proxy::create(devices[device_name]);
  if (tr == NULL) {
    cerr << "Error: could not connect to the timing receiver driver" << endl;
    return -1;
  }
  outs = tr->getOutputs();
  ins = tr->getInputs();
  bg_iface = tr->getInterfaces()["BurstGenerator"];
  if (bg_iface.empty()) {
    cerr << "Error: no burst generator firmware found" << endl;
    return -1;
  }
  bg = BurstGenerator_Proxy::create(bg_iface.begin()->second);
  if (bg == NULL) {
    cerr << "Error: could not connect to the burst generator driver" << endl;
    return -1;
  }
  map<string, string> ecpus = tr->getInterfaces()["EmbeddedCPUActionSink"];
  if (ecpus.empty()) {
    cerr << "Error: no embedded CPU action channel found!" << endl;
    return -1;
  }
  ecpu = EmbeddedCPUActionSink_Proxy::create(ecpus.begin()->second);
  if (ecpu == NULL) {
    cerr << "Error: could not create a proxy for the eCPU action channel" << endl;
    return -1;
  }

  return 0;
}

/* Configure the burst generator according to the given command-line options */
static int bg_do_configuration(void)
{
  int return_code = 0;

  if      (bg_fw_id)       { return_code = bg_get_fw_id(); }
  else if (bg_instr)       { return_code = bg_instruct(bg_instr_args); }
  else if (bg_cfg_io)      { return_code = bg_config_io(bg_t_high, bg_t_p, bg_t_b, bg_b_delay, bg_b_flag, verbose_mode); }
  else if (bg_clr_all)     { return_code = bg_clear_all(verbose_mode); }
  else if (bg_ls_bursts)   { return_code = bg_list_bursts(bg_id, verbose_mode); }
  else if (bg_rm_burst)    { return_code = bg_remove_burst(bg_id, verbose_mode); }
  else if (bg_disen_burst) { return_code = bg_disenable_burst(bg_id, bg_disen, verbose_mode); }
  else if (bg_mk_burst)    { return_code = bg_create_burst(burstId, bg_start_e_id, bg_start_e_mask, bg_stop_e_id, bg_stop_e_mask, verbose_mode); }
  else if (show_table)     { return_code = io_print_table(verbose_mode); }
  else if (ios_wipe)       { return_code = io_snoop(ios_wipe, ios_setup_only, ioc_dis_ios, prefix); }
  else if (ios_snoop)      { return_code = io_snoop(ios_wipe, ios_setup_only, ioc_dis_ios, prefix); }
  else if (ios_setup_only) { return_code = io_snoop(ios_wipe, ios_setup_only, ioc_dis_ios, prefix); }
  else if (ios_i_to_e)     { return_code = io_list_i_to_e(); }
  else if (ioc_create)     { return_code = io_create(ioc_disown, eventID, eventMask, offset, flags, level, negative, translate_mask); }
  else if (ioc_destroy)    { return_code = io_destroy(verbose_mode); }
  else if (ioc_flip)       { return_code = io_flip(verbose_mode); }
  else if (ioc_list)       { return_code = io_list(); }
  else                     { return_code = io_setup(io_oe, io_term, io_spec_out, io_spec_in, io_gate_out, io_gate_in, io_mux, io_pps, io_drive, s_time, set_oe, set_term, set_spec_out, set_spec_in, set_gate_out, set_gate_in, set_mux, set_pps, set_drive, set_stime, verbose_mode); }

  return return_code;
}

/* Reset the internal variables */
static void bg_reset_variables(void)
{
  ioName         = "";    /* Name of the IO */
  ioNameGiven    = false; /* IO name given? */
  ioNameExists   = false; /* IO name does exist? */
  UTC            = false; /* use UTC instead of TAI */
  map_PrefixName.clear();       /* Translation table IO name <> prefix */

  io_oe          = 0;     /* Output enable */
  io_term        = 0;     /* Input Termination */
  io_spec_out    = 0;     /* Special (output) function */
  io_spec_in     = 0;     /* Special (input) function */
  io_gate_out    = 0;     /* Output gate */
  io_gate_in     = 0;     /* Input gate */
  io_mux         = 0;     /* Gate (BuTiS) */
  io_pps         = 0;     /* Gate (PPS) */
  io_drive       = 0;     /* Drive IO value */
  ioc_flip       = 0;     /* Flip active bit for all conditions */
  s_time         = 0;     /* Stable time to set */
  eventID        = 0x0;   /* Event ID (new condition) */
  eventMask      = 0x0;   /* Event mask (new condition) */
  offset         = 0x0;   /* Event offset (new condition) */
  flags          = 0x0;   /* Accept flags (new condition) */
  level          = 0x0;   /* Rising or falling edge (new condition) */
  prefix         = 0x0;   /* IO input prefix */
  translate_mask = false; /* Translate mask? */
  negative       = false; /* Offset negative? */
  ioc_valid      = false; /* Create arguments valid? */
  set_oe         = false; /* Set? */
  set_term       = false; /* Set? */
  set_spec_in    = false; /* Set? */
  set_spec_out   = false; /* Set? */
  set_gate_in    = false; /* Set? */
  set_gate_out   = false; /* Set? */
  set_mux        = false; /* Set? (BuTiS gate) */
  set_pps        = false; /* Set? (PPS gate) */
  set_drive      = false; /* Set? */
  set_stime      = false; /* Set? (Stable time) */
  ios_snoop      = false; /* Snoop on an input(s) */
  ios_wipe       = false; /* Wipe/disable all events from input(s) */
  ios_i_to_e     = false; /* List input to event table */
  ios_setup_only = false; /* Only setup input to event */
  ioc_create     = false; /* Create condition */
  ioc_disown     = false; /* Disown created condition */
  ioc_destroy    = false; /* Destroy condition */
  ioc_list       = false; /* List conditions */
  ioc_dis_ios    = false; /* Disable event source? */
  verbose_mode   = false; /* Print verbose output to output stream => -v */
  show_help      = false; /* Print help => -h */
  show_table     = false; /* Print io mapping table => -i */

  burstId         = 0;     /* burst ID */
  burstIdGiven    = false; /* is burst ID given? */
  bg_start_e_id   = 0x00;  /* Start event ID */
  bg_start_e_mask = ECA_EVENT_MASK;  /* Start event mask */
  bg_stop_e_id    = 0x00;  /* Stop event ID */
  bg_stop_e_mask  = ECA_EVENT_MASK;  /* Stop event mask */
  bg_t_high       = 0x00;  /* Signal active state length, t_high */
  bg_t_p          = 0x00;  /* Signal period, t_p */
  bg_t_b          = 0x00;  /* Burst period, t_b (=0 endless) */
  bg_b_delay      = 0x00;  /* Burst delay, b_d, nanoseconds */
  bg_b_flag       = 0x00;  /* Burst flag, b_f, (=0 new/overwrite, =1 append) */
  bg_disen        = 0;     /* Disable or enable option argument value */
  bg_instr_args.clear() ;  /* Arguments of instruct option */
  bg_id           = 0x00;  /* Burst ID */
  bg_fw_id        = false; /* Get and print the firmware id of the burst generator */
  bg_instr        = false; /* Demo option to test the instruct method call */
  bg_cfg_io       = false; /* Set the ECA conditions for IO actions */
  bg_clr_all      = false; /* Clear all unowned conditions for the IO and eCPU actions */
  bg_ls_bursts    = false; /* List enabled bursts */
  bg_disen_burst  = false; /* Disable or enable burst, id */
  bg_mk_burst     = false; /* Create new burst */
  bg_rm_burst     = false; /* Remove burst */
}

/* Plausibility check on the option arguments */
static int bg_check_arguments(void)
{
  if ((ioc_create || ioc_disown) && ioc_destroy) { std::cerr << "Incorrect arguments!" << std::endl; return (__IO_RETURN_FAILURE); }
  else                                           { ioc_valid = true; }

  if      (ios_snoop && ios_wipe)       { std::cerr << "Incorrect arguments (disable input events or snoop)!"  << std::endl; return (__IO_RETURN_FAILURE);}
  else if (ios_snoop && ios_setup_only) { std::cerr << "Incorrect arguments (enable input events or snoop)!"   << std::endl; return (__IO_RETURN_FAILURE);}
  else if (ios_wipe  && ios_setup_only) { std::cerr << "Incorrect arguments (disable or enable input events)!" << std::endl; return (__IO_RETURN_FAILURE); }

  if (io_oe > 1       || io_oe < 0)       { std::cout << "Error: Output enable setting is invalid!"             << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_term > 1     || io_term < 0)     { std::cout << "Error: Input termination setting is invalid"          << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_spec_out > 1 || io_spec_out < 0) { std::cout << "Error: Special (output) function setting is invalid!" << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_spec_in > 1  || io_spec_in < 0)  { std::cout << "Error: Special (input) function setting is invalid!"  << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_gate_out > 1 || io_gate_out < 0) { std::cout << "Error: Gate (output) setting is invalid!"             << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_gate_in > 1  || io_gate_in < 0)  { std::cout << "Error: Gate (input) setting is invalid!"              << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_mux > 1      || io_mux < 0)      { std::cout << "Error: BuTiS t0 gate/mux setting is invalid!"         << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_pps > 1      || io_pps < 0)      { std::cout << "Error: WR PPS gate/mux setting is invalid!"           << std::endl; return (__IO_RETURN_FAILURE); }
  if (io_drive > 1    || io_drive < 0)    { std::cout << "Error: Output value is not valid!"                    << std::endl; return (__IO_RETURN_FAILURE); }

  if (set_stime)
  {
    if (s_time % 8 != 0)                  { std::cout << "Error: StableTime must be a multiple of 8 ns"         << std::endl; return (__IO_RETURN_FAILURE); }
    if (s_time < 16)                      { std::cout << "Error: StableTime must be at least 16 ns"             << std::endl; return (__IO_RETURN_FAILURE); }
  }

  if (ioNameGiven)
  {
    if (tr == NULL) // no target timing receiver is available
      return (__IO_RETURN_FAILURE);

    /* Check all inputs and outputs */
    for (std::map<std::string,std::string>::iterator it = outs.begin(); it != outs.end(); ++it)
    {
      if (it->first == ioName)          { ioNameExists = true; }
      if (verbose_mode && ioNameExists) { std::cout << "IO " << ioName << " found (output)!" << std::endl; break; }
    }
    for (std::map<std::string,std::string>::iterator it = ins.begin(); it != ins.end(); ++it)
    {
      if (it->first == ioName)          { ioNameExists = true; }
      if (verbose_mode && ioNameExists) { std::cout << "IO " << ioName << " found (input)!" << std::endl; break; }
    }

    /* Inform the user if the given IO does not exist */
    if (!ioNameExists)
    {
      std::cerr << "IO " << ioName << " does not exist!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }
  }

  if (bg_mk_burst)
  {
    if (bg_start_e_id == 0)             { std::cout << "Error: Invalid ID for the start event!" << std::endl; return (__IO_RETURN_FAILURE); }
    if (bg_start_e_id == bg_stop_e_id)  { std::cout << "Error: IDs of the start and stop events must be different!" << std::endl; return (__IO_RETURN_FAILURE); }
  }

  return 0;
}

/* Parse the command-line options */
static int parse_options(int optc, char* optv[], const char* optstr)
{
  int opt = 0;
  optind = 1;   // index must point to the next element

  while ((opt = getopt(optc, optv, optstr)) != -1)
  {
    switch (opt)
    {
      case 'f': { bg_fw_id       = true; break; }
      case 'p': { if (optv[optind-1] != NULL) { bg_t_high = strtoul(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing active state length of a pulse (u32)!" << std::endl; return -1; }
                  if (optv[optind+0] != NULL) { bg_t_p = strtoul(optv[optind+0], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing signal period (u32)!" << std::endl; return -1; }
                  if (optv[optind+1] != NULL) { bg_t_b = strtoll(optv[optind+1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst period (i64)!" << std::endl; return -1; }
                  if (bg_t_b > 0 && (uint64_t)bg_t_b < BG_BURST_PERIOD) { std::cerr << "Error: Burst period exceeds the lower limit of " << BG_BURST_PERIOD << " ns!" << std::endl; return -1; }
                  if (bg_t_high > bg_t_p)     { std::cerr << "Error: Invalid signal parameters, t_high > t_p" << std::endl; return -1; }
                  if (bg_t_b > 0 && bg_t_p > bg_t_b) { std::cerr << "Error: Invalid burst parameters, t_p > t_b" << std::endl; return -1; }
                  if (optv[optind+2] != NULL) { bg_b_delay = strtoull(optv[optind+2], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst delay!" << std::endl; return -1; }
                  if (optv[optind+3] != NULL) { bg_b_flag = strtoul(optv[optind+3], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst flag!" << std::endl; return -1; }
                  if (bg_b_flag > 1)          { std::cerr << "Error: Invalid burst flag! Valid values: 0|1" << std::endl; return -1; }
                  bg_cfg_io      = true;
                  break; }
      case 'e': { if (optv[optind-1] != NULL) { bg_id = strtol(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst id!" << std::endl; return -1; }
                  if (bg_id < 0 || bg_id > N_BURSTS) { std::cerr << "Error: invalid burst id, must be 0 <= id <= " << N_BURSTS << std::endl; return -1; }
                  if (optv[optind+0] != NULL) { bg_disen = strtol(optv[optind+0], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing dis/enable setting!" << std::endl; return -1; }
                  bg_disen_burst = true;
                  break; }
      case 'i': { bg_instr       = true;
                  int index      = optind - 1;
                  while (index < optc)
                  {
                    if (optv[index] != NULL && optv[index][0] != '-') { bg_instr_args.push_back(optv[index]); ++index; }
                    else                                              { optind = index - 1; break; }
                  }
                  if (!bg_instr_args.empty())
                  {
                    std::cout << "Arguments: ";
                    for (vector<string>::iterator it = bg_instr_args.begin(); it != bg_instr_args.end(); ++it)
                      std::cout << *it << ' ';
                    std::cout << std::endl;
                  }
                  break; }
      case 'l': { if (optv[optind-1] != NULL) { bg_id = strtol(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst id!" << std::endl; return -1; }
                  if (bg_id < 0 || bg_id > N_BURSTS)  { std::cerr << "Error: invalid burst id, must be 0 < id <= " << N_BURSTS << std::endl; return -1; }
                  bg_ls_bursts   = true;
                  break; }
      case 'b': { if (optv[optind-1] != NULL) { burstId = strtol(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst id!" << std::endl; return -1; }
                  if (burstId <= 0 || burstId > N_BURSTS)  { std::cerr << "Error: invalid burst id, must be 0 < id <= " << N_BURSTS << std::endl; return -1; }
                  burstIdGiven  = true;
                  break; }
      case 'r': { if (optv[optind-1] != NULL) { bg_id = strtol(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing burst id!" << std::endl; return -1; }
                  if (bg_id <= 0 || bg_id > N_BURSTS) { std::cerr << "Error: invalid burst id, must be 0 < id <= " << N_BURSTS << std::endl; return -1; }
                  bg_rm_burst   = true;
                  break; }
      case 's': { if (optv[optind-1] != NULL) { bg_start_e_id = strtoull(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing an ID for the start event!" << std::endl; return -1; }
                  bg_mk_burst   = true;
                  break; }
      case 't': { if (optv[optind-1] != NULL) { bg_stop_e_id = strtoull(optv[optind-1], &pEnd, 0); }
                  else                        { std::cerr << "Error: Missing an ID for the stop event!" << std::endl; return -1; }
                  break; }
      case 'x': { bg_clr_all    = true;
                  break; }
      case 'n': { ioName         = optv[optind - 1]; ioNameGiven  = true; break; }
      case 'v': { verbose_mode   = true; break; }
      case 'h': { show_help      = true; break; }
      case 'o': { if (optv[optind-1] != NULL) { optFileName = string(optv[optind-1]); }
                  else                        { std::cerr << "Error: Missing file name!" << std::endl; return -1; }
                  break; }
      case ':': { std::cout << "Option -" << (char)optopt << " requires argument(s)!" << std::endl; show_help = true; break; }
      default:  { std::cout << "Unknown option: " << (char)optopt << std::endl; show_help = true; break; }
    }
    // break loop if help is requested
    if (show_help) { return -1; }
  }

  return 0;
}

/* Parse the burst generation options */
static int bg_parse_options(const std::string& options, const char* optstring)
{
  // clear option buffer
  memset(opt_buf, '\0', sizeof(opt_buf));

  // get the number of option elements, optc
  strcpy(opt_buf, options.c_str());
  int optc = 0;

  char *opt = std::strtok(opt_buf, " ");
  while (opt != NULL) {
   ++optc;
   opt = std::strtok(NULL, " ");
  }

  // create and set up an option vector, optv
  strcpy(opt_buf, options.c_str());
  char* optv[optc];
  int i = 0;

  optv[i] = std::strtok(opt_buf, " ");

  while (optv[i] != NULL)
  {
    ++i;
    optv[i] = std::strtok(NULL, " ");
  }

  //std::cout << "optc = " << optc << std::endl << "optstring = " << optstring << std::endl;
  std::cout << "Parsing options : ";

  for (i = 0; i < optc; ++i)
    std::cout << optv[i] << " ";

  std::cout << std::endl;

  return parse_options(optc, optv, optstring);
}

/* Extract options from a single string */
/*static std::vector<std::string> bg_extract_options(const std::string& str, const std::string& rule)
{
  // elements     : option format
  //
  // <io>         : -n name_str
  // <burst>      : -b id_n
  // <start_evt>  : -s evt_id_u32 evt_mask_u32
  // <stop_evt>   : -t evt_id_u32 evt_mask_u32
  // <parameter>  : -p s_widht_u32 s_period_u32 b_period_u32 b_delay_32 b_flag_bool
  //
  // rules        : option format
  //
  // <create>     : <io> <burst> <start_evt> <stop_evt> <parameter>
  // <list>       : -l id_n
  // <en_disable> : -e id_n disen_bool
  // <remove>     : -r id_n
  // <update>     : -i id_n cycle_hi_u32 cycle_lo_32
  // <clear_all>  : -x

  typedef std::vector<std::string>::const_iterator v_iter;

  // rules
  static const std::vector<std::string> rules = { "nbstp", "l", "e", "r", "i", "x"};
  std::map<int, std::string> ruled_options;

  std::vector<std::string> options = bg_split(str, '-');

  v_iter opt = options.begin();
  while (opt != options.end())
  {
    //std::cout << *opt << std::endl;
    int cnt = 0;

    for (v_iter rule = rules.begin(); rule != rules.end(); ++rule, ++cnt)
    {
      //std::cout << (*opt).front() << std::endl;
      if ((*rule).find((*opt).front()) != std::string::npos)
      {
        ruled_options[cnt].append("-" + *opt + " ");
        break;
      }
    }

    ++opt;
  }

  for (std::size_t i = 0; i < ruled_options.size(); ++i)
    std::cout << ruled_options[i] << std::endl;

  return options;
}*/

/* Check if string is comment (string started with '#') */
static bool bg_is_comment(const std::string& str)
{
  return *str.cbegin() == '#';
}

/* Asyncronous method call to invoke a burst generator instruction */
static int  bg_invoke_async(std::shared_ptr<BurstGenerator_Proxy> bg, uint32_t inst_code, std::vector<uint32_t> inst_args)
{
  if (bg == NULL)
    return -1;

  if (bg->instruct(inst_code, inst_args)) // send an instruction to the burst generator
  {
    std::cerr << "Failed to send an instruction to the burst generator: " << inst_code << std::endl;
    return -1;
  }

  saftlib::wait_for_signal(3000);         // wait for response or time-out (burst generator checks its mailbox every second)

  uint32_t response = bg->getResponse();  // check response
  if ((response & 0xFFFF) != inst_code)
    return -1;

  return (response >> 16) & 0xFFFF;       // return instruction result, if instruction is complete
}

/* Print help message to check created bursts */
static void bg_help(char option)
{
  switch (option)
  {
    case 'l' :
      std::cout << "Use the command option -" << option << " to print a list of created bursts." << std::endl;
      break;
    default :
      break;
  }
}

/* Get the firmware id of the burst generator */
/* ==================================================================================================== */
static int bg_get_fw_id(void)
{
  try
  {
    std::vector<uint32_t> args;
    args.push_back(0);

    if (bg_invoke_async(bg, CMD_LS_FW_ID, args))
    {
      std::cerr << "Failed to get the firmware ID. Try again!" << std::endl;
      return -1;
    }

    args.clear();
    args = bg->readSharedBuffer(1);
    if (args.size() > 0)
    {
      std::cout << "Got firmware id: 0x" << std::hex << args.at(0) << std::endl;
    }
    else
    {
      std::cerr << "Could not get the firmware id." << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return 0;
}

/* Instruct the burst generator */
/* ==================================================================================================== */
static int bg_instruct(std::vector<std::string> instr)
{
  if (instr.empty())
  {
    std::cerr << "Missing arguments for method call bg_instruct()" << std::endl;
    return -1;
  }

  try
  {
    std::vector<std::string>::iterator it = instr.begin();

    std::vector<uint32_t> instr_args;
    uint32_t instr_code = strtoul((*it).c_str(), NULL, 0);
    ++it;

    while (it != instr.end())
    {
      instr_args.push_back(strtoul((*it).c_str(), NULL, 0));
      ++it;
    }

    if (bg_invoke_async(bg, instr_code, instr_args))
      std::cerr << "Failed method call bg_instruct()!" << std::endl;
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return 0;
}

/* Find the IO port name based on the given burst info */
static std::string find_io_name(std::shared_ptr<TimingReceiver_Proxy> tr, std::vector<uint32_t> info)
{
  std::shared_ptr<Output_Proxy> out_proxy;

  std::string out_type_name = "undefined";
  switch (info.at(1)) {
    case IO_CFG_CHANNEL_GPIO: out_type_name = "8ns"; break;
    case IO_CFG_CHANNEL_LVDS: out_type_name = "1ns"; break;
    default: break;
  }

  for (std::map<std::string,std::string>::iterator it = outs.begin(); it != outs.end(); ++it)
  {
    out_proxy = Output_Proxy::create(it->second);

    if (out_proxy != NULL)
    {
      std::size_t found = out_proxy->getTypeOut().find(out_type_name);
      if (found != std::string::npos)
      {
        if (out_proxy->getIndexOut() == info.at(2))
          return it->first;
      }
    }
  }

  return std::string();
}
/* Determine the IO port name from the burst declaration */
static int bg_get_io_name(int burst_id, std::string &name)
{
  if (burst_id == 0)
  {
    std::cerr << "Invalid burst ID!" << std::endl;
    return -1;
  }

  try
  {
    std::vector<uint32_t> info;
    info.push_back(burst_id);

    if (bg_invoke_async(bg, CMD_LS_BURST, info))
    {
      std::cerr << "Failed to get the burst info. Try again!" << std::endl;
      return -1;
    }

    info = bg->readBurstInfo(burst_id);
    if (info.size() == 0)
    {
      std::cerr << "Failed to get burst info" << std::endl;
      return -1;
    }

    name = find_io_name(tr, info);
    return 0;
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return 0;
}

/* List currently enabled bursts */
static int bg_list_bursts(int burst_id, bool verbose_mode)
{
  try
  {
    std::vector<uint32_t> args;
    args.push_back(burst_id);
    args.push_back((uint32_t)verbose_mode);

    if (bg_invoke_async(bg, CMD_LS_BURST, args))
    {
      std::cerr << "Failed to get the burst info. Try again!" << std::endl;
      return -1;
    }

    args = bg->readBurstInfo(burst_id);

    if (args.empty())
    {
      std::cerr << "Something went wrong on reading the burst info! Try again." << std::endl;
      return -1;
    }

    if (burst_id)
    {
      std::cout << "Burst info: " << std::showbase;
      for (unsigned int i = 0; i < args.size(); ++i)
        std::cout << ' ' << std::hex << args.at(i);
      std::cout << std::endl;
      if (verbose_mode && args.size() == N_BURST_INFO)
        print_burst_info(args);
    }
    else
    {
      std::cout << "Created (" << std::showbase << std::hex << args.at(0) << ") : ";
      std::cout << std::noshowbase << std::dec;
      uint32_t mask = 1;
      int id = 1;

      while (mask != 0)
      {
        if (args.at(0) & mask)
          std::cout << ' ' << id;
        ++id;
        mask <<=1;
      }
      std::cout << std::endl;

      std::cout << "Cycled (" << std::showbase << std::hex << args.at(1) << ") : ";
      std::cout << std::noshowbase << std::dec;
      mask = 1; id = 1;
      while (mask != 0)
      {
        if (args.at(1) & mask)
          std::cout << ' ' << id;
        ++id;
        mask <<=1;
      }
      std::cout << std::endl;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return 0;
}

/* Remove burst */
static int bg_remove_burst(int burst_id, bool verbose)
{
  int result = 0;

  // destroy all conditions for the chosen burst (IO)
  std::string name;

  if (bg_get_io_name(burst_id, name))
  {
    std::cout << "Failed to determine IO name" << std::endl;
    return -1;
  }

  if (name.empty())
  {
    std::cout << "Could not determine IO name" << std::endl;
    return -1;
  }

  ioName = name.c_str();
  ioNameGiven = true;

  result = io_destroy(true);

  if (result != 0)
    std::cerr << "Failed to destroy conditions!" << std::endl;

  try
  {
    std::vector<uint32_t> args;
    args.push_back(burst_id);
    args.push_back(static_cast<uint32_t>(verbose));

    if (bg_invoke_async(bg, CMD_RM_BURST, args))
    {
      std::cerr << "Failed to disable burst" << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

/* Dis/enable burst */
static int bg_disenable_burst(int burst_id, int disen, bool verbose)
{
  try
  {
    std::vector<uint32_t> args;
    args.push_back(0);

    if (bg_invoke_async(bg, CMD_LS_BURST, args))
    {
      std::cerr << "Failed to get the burst info. Try again!" << std::endl;
      return -1;
    }

    args.clear();
    args = bg->readBurstInfo(0);
    if (args.size() > 0)
    {
      uint32_t burstIdMask = 0x1 << (burst_id - 1);
      if ((args.at(0) & burstIdMask) == 0)
      {
        std::cerr << "Could not find a burst with id: " << burst_id << std::endl;
        bg_help('l');
        return -1;
      }
    }
    else
    {
      std::cerr << "Could not get required burst info." << std::endl;
      return -1;
    }

    args.clear();
    args.push_back(burst_id);
    args.push_back(disen);
    args.push_back(static_cast<uint32_t>(verbose));

    if (bg_invoke_async(bg, CMD_DE_BURST, args))
    {
      std::cerr << "Failed to disable a burst. Try again!" << std::endl;
      return -1;
    }
 }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return 0;
}

/* Create new burst */
static int bg_create_burst(int burst_id, uint64_t e_id, uint64_t e_mask, uint64_t stop_e_id, uint64_t stop_e_mask, bool verbose)
{
  int result = 0;

  if (ioNameGiven == false || ioName == NULL)
  {
    std::cerr << "Missing IO name!" << std::endl;
    return -1;
  }

  if (!burstIdGiven)
  {
    std::cerr << "Missing burst ID!" << std::endl;
    return -1;
  }

  try
  {
    std::shared_ptr<Output_Proxy> out_proxy = NULL;

    std::map<std::string,std::string>::iterator it = outs.begin();
    while (out_proxy == NULL && it != outs.end())
    {
      if (it->first == ioName)
        out_proxy = Output_Proxy::create(it->second);
      ++it;
    }

    if (out_proxy == NULL)
    {
      std::cerr << "Not found the IO port " << ioName << std::endl;
      return -1;
    }

    /* firmware ID is used as a tag */
    uint32_t tag = 0;
    std::vector<uint32_t> args;
    args.push_back(0);

    if (bg_invoke_async(bg, CMD_LS_FW_ID, args))
    {
      std::cerr << "Failed to get the firmware ID. Try again!" << std::endl;
      return -1;
    }

    args.clear();
    args = bg->readSharedBuffer(1);
    if (args.size())
      tag = args.at(0);

    /* Check if the same conditions for eCPU actions exist already */
    int check = ecpu_check(e_id, e_mask, 0, tag);

    if (check < 0)
    {
      std::cerr << "Failed to check conditions for eCPU actions" << std::endl;
      return -1;
    }
    else if (check == 0) // conditions were not set
    {
      /* Configure ECA with the conditions for eCPU actions */
      if (ecpu_update(e_id, e_mask, 0, tag, verbose))  // TODO: apply offset?
      {
        std::cerr << "Failed to set conditions for eCPU actions" << std::endl;
        return -1;
      }
    }

    /* Set condition only if the stop event ID is non-zero. Otherwise all existing eCPU conditions will be erased! */
    if (stop_e_id)
    {
      check = ecpu_check(stop_e_id, stop_e_mask, 0, tag);

      if (check < 0)
      {
        std::cerr << "Failed to check conditions for eCPU actions" << std::endl;
        return -1;
      }
      else if (check == 0) // conditions were not set
      {
        /* Configure ECA with the conditions for eCPU actions */
        if (ecpu_update(stop_e_id, stop_e_mask, 0, tag, verbose))  // TODO: apply offset?
        {
          std::cerr << "Failed to set conditions for eCPU actions" << std::endl;
          return -1;
        }
      }
    }

    /* Set up IO port */
    int io_oe = 1;
    int io_drive = 0;
    bool set_oe = true;
    bool set_drive = true;

    result = io_setup(io_oe, 0, 0, 0, 0, 0, 0, 0, io_drive, 0,
          set_oe, false, false, false, false, false, false, false, set_drive, false, true);

    if (result != 0)
    {
      std::cerr << "Failed to set up IO: " << ioName << std::endl;
      return result;
    }

    std::shared_ptr<Input_Proxy> in_proxy = Input_Proxy::create(tr->getInputs()[ioName]);
    if (in_proxy)
      in_proxy->setEventEnable(false);                   // disable event source for the IO port

    uint32_t out_type = IO_CFG_CHANNEL_FIXED;            // io_control_regs.h
    std::string out_type_name = out_proxy->getTypeOut(); // missing a member function to get integer type in Inoutimpl
    if (out_type_name.find("8ns") != std::string::npos)
      out_type = IO_CFG_CHANNEL_GPIO;
    else if (out_type_name.find("1ns") != std::string::npos)
      out_type = IO_CFG_CHANNEL_LVDS;

    args.clear();
    args.push_back(burst_id);
    args.push_back((out_type << 16) | (out_proxy->getIndexOut() & 0xFFFF));
    args.push_back((uint32_t)(e_id >> 32));
    args.push_back((uint32_t)e_id);
    args.push_back((uint32_t)(stop_e_id >> 32));
    args.push_back((uint32_t)stop_e_id);
    args.push_back(static_cast<uint32_t>(verbose));

    if (bg_invoke_async(bg, CMD_MK_BURST, args))
    {
      std::cerr << "Failed to enable burst" << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

/* Check if the given conditions for IO actions is already set */
static int io_check(uint64_t e_id, bool &found)
{
  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::shared_ptr<Output_Proxy> output_proxy;

    /* Check if IO exists output */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      output_proxy = Output_Proxy::create(it->second);

      std::vector< std::string > all_conditions = output_proxy->getAllConditions();

      for (unsigned int condition_it = 0; condition_it < all_conditions.size(); condition_it++)
      {
         /* Get output conditions */
         std::shared_ptr<OutputCondition_Proxy> info_condition = OutputCondition_Proxy::create(all_conditions[condition_it]);
         if (info_condition->getID() == e_id) {
           found = true;

           if (verbose_mode)
            std::cout << "Info: conditions with event " << std::hex << e_id << " is set for IO action" << std::endl;

           break;
         }
      }
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke io_check(): " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

static void print_burst_info(std::vector<uint32_t> info)
{
  if (tr == NULL)
    return;
  std::cout << "Burst info (text):";
  std::cout << " id = " << info.at(0) <<
    ", io type = " << info.at(1) << ", io index = " << info.at(2) <<
    ", start = " << std::hex << info.at(3) << ':' << info.at(4) <<
    ", stop = " << info.at(5) << ':' << info.at(6) <<
    ", cycle = " << info.at(7) << ':' << info.at(8) <<
    ", enabled = " << ((info.at(9) & CTL_EN) ? "yes" : "no") << std::endl;
}

/* Configure ECA with the IO event conditions for generating pulse at the chosen output */
/* ==================================================================================================== */
static int  bg_config_io(uint32_t t_high, uint32_t t_period, int64_t t_burst, uint64_t b_delay, uint32_t b_flag, bool verbose_mode)
{
  int result = 0;

  // check arguments
  if (ioNameGiven == false || ioName == NULL)
  {
    if (burstId == 0)
    {
      std::cerr << "Missing IO name!" << std::endl;
      return -1;
    }
  }

  if (!burstIdGiven)
  {
    std::cerr << "Missing burst ID!" << std::endl;
    return -1;
  }

  if (t_period == 0)
  {
    std::cerr << "Bad arguments: t_period = " << t_period << std::endl;
    return -1;
  }

  uint32_t n_main_conditions = 2; // main conditions (for a pulse block)
  uint32_t n_rem_conditions = 0;  // remaining conditions (finite burst)
  uint32_t n_conditions = 2;      // single pulse is generated by two IO actions
  uint32_t t_block = t_period;    // block is a repeated sequence in a burst
  int64_t  n_block = 0;           // number of blocks to be repeated/cycled
  uint32_t t_rem = 0;             // remaining part of a finite burst (not fitted in a block)

  if (t_high == 0 || t_high == t_period)  // drive IO signal
  {
    n_conditions = 1;
  }
  else if (t_period < BG_BURST_PERIOD)    // pulse period is shorter than block production period
  {
    // determine number of blocks, IO condtions and period of a block
    while(t_block < BG_BURST_PERIOD)
    {
      t_block += t_period;    // determine a block length, ns
      n_main_conditions +=2;  // count the main conditions for a pulse block
    }

    // finite burst: determine a few remaining conditions that cannot fit in a block
    t_rem = t_burst % t_block;                         // remaining part of a finite burst that cannot fit in a block
    uint32_t n_pulses = t_rem / t_period;              // number of pulses in this part
    uint32_t n_rest = (t_rem - n_pulses * t_period) / t_high;  // the rest of burst that can be expressed by a condition
    n_rem_conditions = 2 * n_pulses + n_rest;          // remaining conditions

    // determine a number of conditions for IO actions
    n_conditions = n_main_conditions + n_rem_conditions;
  }

  if (t_burst > 0) {          // finite burst -> determine a number of blocks
    n_block = t_burst / t_block;
    n_block--;                // 1 block for burst head and rest are for burst body
  }
  else                        // infinite burst -> infinite number of blocks
    n_block = -1;

  if (verbose_mode) {
    std::cout << "+++ input: t_high=" << t_high << " t_period=" << t_period << " t_burst=" << t_burst << std::endl;
    std::cout << "+++ config:" << std::endl
     << " t_block=" << std::dec << t_block << " (" << std::hex << t_block << ") block period, ns" << std::endl
     << " t_rem=" << std::dec << t_rem << " (" << std::hex << t_rem << ") remaining period, ns" << std::endl
     << " n_block=" << std::dec << n_block << " (" << std::hex << n_block << ") # of blocks for loop " << std::endl
     << " n_main_conditions=" << std::dec << n_main_conditions << " (" << std::hex << n_main_conditions << ") main pulses" << std::endl
     << " n_rem_conditions=" << std::dec << n_rem_conditions << " (" << std::hex << n_rem_conditions << ") remaining pulses" << std::endl
     << " n_conditions=" << std::dec << n_conditions << " (" << std::hex << n_conditions << ") total ECA conditions" << std::endl;
  }

  std::vector<uint32_t> args;

  try
  {
    // check free place in ECA
    uint32_t eca_entries = tr->getFree();
    if (n_conditions > eca_entries)
    {
      std::cerr << "Not enough space is available for the desired conditions! Needs: " << n_conditions << ", available: " << eca_entries << std::endl;
      return -1;
    }

    // check if the given burst is created
    args.push_back(burstId);

    if (bg_invoke_async(bg, CMD_LS_BURST, args))
    {
      std::cerr << "Failed to get the burst info. Try again!" << std::endl;
      return -1;
    }

    args.clear();
    args = bg->readBurstInfo(burstId);
    if (args.size() != N_BURST_INFO)
    {
      std::cerr << "Could not get required burst info." << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  std::cout << "Burst info: " << std::showbase;
  for (unsigned int i = 0; i < args.size(); ++i)
    std::cout << ' ' << std::hex << args.at(i);
  std::cout << std::endl;
  if (verbose_mode)
    print_burst_info(args);

  std::string name = find_io_name(tr, args);

  if (name.empty())
  {
    std::cout << "Could not determine IO name" << std::endl;
    return -1;
  }

  ioName = name.c_str();
  ioNameGiven = true;

  std::cout << std::showbase;

  bool disown = true;
  uint64_t flags  = 0xf;
  uint64_t level  = 1;

  uint64_t offset = b_delay;
  uint64_t t_low = t_period - t_high;

  uint64_t _e_id = args.at(INFO_START_EVT_H32);
  _e_id <<= 32;
  _e_id |= args.at(INFO_START_EVT_L32);
  uint64_t _e_mask = EVT_MASK_IO;

  bool conditions_exist = false;
  io_check(_e_id, conditions_exist);

  if (!b_flag && conditions_exist) // destroy existing conditions, if new pulse parameter is given (by burst flag)
  {
    io_destroy(verbose_mode);
  }

  // set conditions
  if (n_conditions == 1)
  {
    if (t_high == t_period)
      level = 1;
    else
      level = 0;

    result = io_create(disown, _e_id, _e_mask, offset, flags, level, false, false);

    if (result != 0)
    {
      std::cerr << "Failed to create a condition for burst: id = "
        << std::hex << _e_id << " mask = " << _e_mask << std::endl;
      io_destroy(true); // destroy conditions that were created
      return result;
    }
    else if (verbose_mode)
      std::cout << "id = " << std::hex << _e_id << "msk = " << _e_mask
        << std::dec << " offset = " << offset << " level = " << level << std::endl;
  }
  else
  {
    // conditions for burst head (1 block + remaining)
    for (uint32_t i = 0; i < n_conditions; i++)
    {
      result = io_create(disown, _e_id, _e_mask, offset, flags, level, false, false);

      if (result != 0)
      {
        std::cerr << "Failed to create conditions for burst head: id = "
          << std::hex << _e_id << " mask = " << _e_mask  << std::endl;
        io_destroy(true); // destroy conditions that were created
        return result;
      }
      else if (verbose_mode)
        std::cout << "id = " << std::hex << _e_id << " msk = " << _e_mask
          << std::dec << " offset = " << offset << " level = " << level << std::endl;

      if ( i % 2 == 0)
        offset += t_high;
      else
        offset += t_low;

      level ^=1;
    }

    // set conditions for burst body only if block loop is needed
    if (n_block) {
      _e_id = EVT_ID_IO_H32 + (burstId << 4);
      _e_id <<=32;
      offset = 0;

      conditions_exist = false;
      io_check(_e_id, conditions_exist);

      if (!b_flag && conditions_exist) // destroy existing conditions, if new pulse parameter is given (by burst flag)
      {
        io_destroy(verbose_mode);
      }

      for (uint32_t i = 0; i < n_main_conditions; i++)
      {
        result = io_create(disown, _e_id, _e_mask, offset, flags, level, false, false);

        if (result != 0)
        {
          std::cerr << "Failed to create conditions for burst body: id = " << std::hex << _e_id
            << " mask = " << _e_mask  << std::endl;
          io_destroy(true); // destroy conditions that were created
          return result;
        }
        else if (verbose_mode)
          std::cout << "id = " << std::hex << _e_id << " msk = " << _e_mask
            << std::dec << " offset = " << offset << " level = " << level << std::endl;

        if ( i % 2 == 0)
          offset += t_high;
        else
          offset += t_low;

        level ^=1;
      }
    }
  }

  try
  {
    std::vector<uint32_t> args;

    // pack burst parameters (id, delay, number of conditions, block period, burst flag)
    args.push_back(burstId);
    args.push_back(t_block + t_rem);         // setup time period (setup = block + remaining)
    args.push_back(n_main_conditions);       // number of conditions in a block
    args.push_back(t_block);                 // block period
    args.push_back(b_flag);
    args.push_back((uint32_t)verbose_mode);

    std::cout << "Pulse params: ";
    for ( std::vector<uint32_t>::iterator it = args.begin(); it != args.end(); ++it)
      std::cout << std::hex << *it << ' ';
    std::cout << std::endl;

    if (bg_invoke_async(bg, CMD_GET_PARAM, args))
    {
      std::cerr << "Failed to send the pulse parameters. Try again!" << std::endl;
      return -1;
    }

    args.clear();

    // pack block production parameters (id, high and low bytes in number of blocks)
    args.push_back(burstId);
    args.push_back(n_block >> 32);
    args.push_back(n_block);
    args.push_back((uint32_t)verbose_mode);

    std::cout << "Block production: ";
    for ( std::vector<uint32_t>::iterator it = args.begin(); it != args.end(); ++it)
      std::cout << std::hex << *it << ' ';
    std::cout << std::endl;

    if (bg_invoke_async(bg, CMD_GET_CYCLE, args))
    {
      std::cerr << "Failed to send block production parameters." << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

static int ecpu_destroy(bool verbose_mode)
{
  int result = 0;

  try
  {
    if (ecpu)
    {
      std::shared_ptr<EmbeddedCPUCondition_Proxy> condition;
      std::string ecpu_sink;
      std::vector<std::string> n_conditions = ecpu->getAllConditions();

      for (unsigned int it = 0; it < n_conditions.size(); it++)
      {
        ecpu_sink = n_conditions[it];

        condition = EmbeddedCPUCondition_Proxy::create(ecpu_sink);
        if (condition->getDestructible() && (condition->getOwner() == ""))
        {
          condition->Destroy();
          if (verbose_mode)
            std::cout << "Destroyed " << ecpu_sink << std::endl;
        }
        else
        {
          if (verbose_mode)
            std::cout << "Found not destructible " << ecpu_sink << std::endl;
        }
      }
    }
    else
    {
      std::cerr << "eCPU action sink is not available!" << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

/* Configure ECA with the event conditions for eCPU actions */
static int  ecpu_update(uint64_t e_id, uint64_t e_mask, int64_t offset, uint32_t tag, bool verbose)
{
  int result = 0;

  // request to destroy all conditions for the chosen IO
  if (e_id == 0)
  {
    result = ecpu_destroy(verbose);
    if (result != 0)
      std::cerr << "Failed to destroy conditions!" << std::endl;

    return result;
  }

  if (tag == 0)
  {
    std::cerr << "Bad arguments: tag = " << std::showbase << std::hex << tag << std::endl;
    return -1;
  }

  try
  {
    /* Check space in the condition table */
    if (tr->getFree() == 0)
    {
      std::cerr << "Error: Cannot set the given condition! Condition table is full." << std::endl;
      return -1;
    }

    /* Create the action sink */
    if (ecpu)
    {
      std::vector<std::string> n_conditions;
      std::shared_ptr<EmbeddedCPUCondition_Proxy> condition;
      std::string ecpu_sink;

      ecpu_sink = ecpu->NewCondition(true, e_id, e_mask, offset, tag);
      condition = EmbeddedCPUCondition_Proxy::create(ecpu_sink);

      condition->setAcceptConflict(true);
      condition->setAcceptDelayed(true);
      condition->setAcceptEarly(true);
      condition->setAcceptLate(true);
      condition->Disown();
    }
    else
    {
      std::cerr << "eCPU action sink is not available!" << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

/* Check if the given conditions for eCPU actions is already set */
static int  ecpu_check(uint64_t e_id, uint64_t e_mask, int64_t offset, uint32_t tag)
{
  int result = 0;

  // check arguments
  if (ioNameGiven == false || ioName == NULL)
  {
    std::cerr << "Missing IO name!" << std::endl;
    return -1;
  }

  // request to destroy all conditions for the chosen IO
  if (e_id == 0)
  {
    result = ecpu_destroy(true);
    if (result != 0)
      std::cerr << "Failed to destroy conditions!" << std::endl;

    return result;
  }

  if (tag == 0)
  {
    std::cerr << "Bad arguments: tag = " << std::showbase << std::hex << tag << std::endl;
    return -1;
  }

  try
  {
    /* Create the action sink */
    if (ecpu)
    {
      /* Check if desired conditions already exist */
      std::vector<std::string> n_conditions = ecpu->getAllConditions();

      for (unsigned int c = 0; c < n_conditions.size(); c++)
      {
        std::shared_ptr<EmbeddedCPUCondition_Proxy> c_proxy = EmbeddedCPUCondition_Proxy::create(n_conditions[c]);

        if (c_proxy)
        {
          if (c_proxy->getID() == e_id && c_proxy->getMask() == e_mask &&
              c_proxy->getTag() == tag && c_proxy->getOffset() == offset)
          {
            std::cerr << "The given condition for eCPU already exists!" << std::endl;
            return 1;
          }
       }
      }
    }
    else
    {
      std::cerr << "eCPU action sink is not available!" << std::endl;
      return -1;
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return -1;
  }

  return result;
}

/* Clear all unowned conditions for the IO and eCPU actions */
static int bg_clear_all(bool verbose)
{
  int result = ecpu_update(0, 0, 0, 0, verbose);
  result |= io_destroy(verbose);
  return result;
}

/* Function io_create() */
/* ==================================================================================================== */
static int io_create (bool disown, uint64_t eventID, uint64_t eventMask, int64_t offset, uint64_t flags, int64_t level, bool offset_negative, bool translate_mask)
{
  /* Helpers */
  bool   io_found          = false;
  bool   io_edge           = false;
  bool   io_AcceptConflict = false;
  bool   io_AcceptDelayed  = false;
  bool   io_AcceptEarly    = false;
  bool   io_AcceptLate     = false;
  int64_t io_offset         = offset;

  /* Get level/edge */
  if (level > 0) { io_edge = true; }
  else           { io_edge = false; }

  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::shared_ptr<Output_Proxy> output_proxy;

    /* Check flags */
    if (flags & (1 << ECA_LATE))     { io_AcceptLate = true; }
    if (flags & (1 << ECA_EARLY))    { io_AcceptEarly = true; }
    if (flags & (1 << ECA_CONFLICT)) { io_AcceptConflict = true; }
    if (flags & (1 << ECA_DELAYED))  { io_AcceptDelayed = true; }

    /* Check if a negative offset is wanted */
    if (offset_negative) { io_offset = io_offset*-1; }

    /* Check if IO exists output */
    if (ioNameGiven)
    {
      for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
      {
        if (it->first == ioName)
        {
          io_found = true;
          output_proxy = Output_Proxy::create(it->second);
          io_path = it->second;
        }
      }
    }

    /* Found IO? */
    if (ioNameGiven == false)
    {
      std::cerr << "Error: No IO given!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }
    else if (io_found == false)
    {
      std::cerr << "Error: There is no IO (output) with the name " << ioName << "!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }

    /* Setup condition */
    std::shared_ptr<OutputCondition_Proxy> condition;
    if (translate_mask) { condition = OutputCondition_Proxy::create(output_proxy->NewCondition(true, eventID, tr_mask(eventMask), io_offset, io_edge)); }
    else                { condition = OutputCondition_Proxy::create(output_proxy->NewCondition(true, eventID, eventMask, io_offset, io_edge)); }
    condition->setAcceptConflict(io_AcceptConflict);
    condition->setAcceptDelayed(io_AcceptDelayed);
    condition->setAcceptEarly(io_AcceptEarly);
    condition->setAcceptLate(io_AcceptLate);

    /* Disown and quit or keep waiting */
    if (disown) { condition->Disown(); }
    else        { std::cout << "Condition created..." << std::endl;
      while(true) {
        saftlib::wait_for_signal();
      }
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_destroy() */
/* ==================================================================================================== */
static int io_destroy (bool verbose_mode)
{
  /* Helper */
  std::string c_name = "Unknown";
  std::vector <std::shared_ptr<OutputCondition_Proxy> > prox;

  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::shared_ptr<Output_Proxy> output_proxy;

    /* Check if IO exists output */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      output_proxy = Output_Proxy::create(it->second);
      std::vector< std::string > all_conditions = output_proxy->getAllConditions();
      for (unsigned int condition_it = 0; condition_it < all_conditions.size(); condition_it++)
      {
        if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
        {
          std::shared_ptr<OutputCondition_Proxy> destroy_condition = OutputCondition_Proxy::create(all_conditions[condition_it]);
          c_name = all_conditions[condition_it];
          if (destroy_condition->getDestructible() && (destroy_condition->getOwner() == ""))
          {
            prox.push_back ( OutputCondition_Proxy::create(all_conditions[condition_it]));
            prox.back()->Destroy();
            if (verbose_mode) { std::cout << "Destroyed " << c_name << "!" << std::endl; }
          }
          else
          {
            if (verbose_mode) { std::cout << "Found " << c_name << " but is not destructible!" << std::endl; }
          }
        }
      }
    }

  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_flip() */
/* ==================================================================================================== */
static int io_flip (bool verbose_mode)
{
  /* Helper */
  std::string c_name = "Unknown";

  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::shared_ptr<Output_Proxy> output_proxy;
    std::vector< std::string > conditions_to_destroy;

    /* Check if IO exists output */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      output_proxy = Output_Proxy::create(it->second);
      std::vector< std::string > all_conditions = output_proxy->getAllConditions();
      for (unsigned int condition_it = 0; condition_it < all_conditions.size(); condition_it++)
      {
        if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
        {
          std::shared_ptr<OutputCondition_Proxy> flip_condition = OutputCondition_Proxy::create(all_conditions[condition_it]);
          c_name = all_conditions[condition_it];

          /* Flip unowned conditions */
          if ((flip_condition->getOwner() == ""))
          {
            if (verbose_mode) { std::cout << "Flipped " << c_name; }
            if (flip_condition->getActive())
            {
              flip_condition->setActive(false);
              if (verbose_mode) { std::cout << " to inactive!" << std::endl; }
            }
            else
            {
              flip_condition->setActive(true);
              if (verbose_mode) { std::cout << " to active!" << std::endl; }
            }
          }
          else
          {
            if (verbose_mode) { std::cout << "Found " << c_name << " but is already owned!" << std::endl; }
          }
        }
      }
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_list() */
/* ==================================================================================================== */
static int io_list (void)
{
  /* Helpers */
  bool     io_found     = false;
  bool     header_shown = false;
  std::string c_name  = "Unknown";

  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::shared_ptr<Output_Proxy> output_proxy;

    /* Check if IO exists output */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      output_proxy = Output_Proxy::create(it->second);

      if(!header_shown)
      {
        /* Print table header */
        std::cout << "IO             Number      ID                  Mask                Offset      Flags       Edge     Status    Owner   " << std::endl;
        std::cout << "----------------------------------------------------------------------------------------------------------------------" << std::endl;
        header_shown = true;
      }

      if (ioNameGiven && (it->first == ioName)) { io_found = true; }
      std::vector< std::string > all_conditions = output_proxy->getAllConditions();

      for (unsigned int condition_it = 0; condition_it < all_conditions.size(); condition_it++)
      {
        if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
        {
          /* Helper for flag information field */
          uint32_t  flags = 0x0;

          /* Get output conditions */
          std::shared_ptr<OutputCondition_Proxy> info_condition = OutputCondition_Proxy::create(all_conditions[condition_it]);
          c_name = all_conditions[condition_it];
          std::string str_path_and_id = it->first;
          std::string str_path        = it->second;
          std::string cid             = c_name;
          std::string cid_prefix      = "/_";

          /* Extract IO name */
          cid.replace(str_path.find(str_path),str_path.length(),"");
          cid.replace(cid_prefix.find(cid_prefix),cid_prefix.length(),"");

          /* Output ECA condition table */
          std::cout << std::left;
          std::cout << std::setw(12+2) << it->first << " ";
          std::cout << std::setw(10+1) << cid << " ";
          std::cout << "0x";
          std::cout << std::setw(16+1) << std::hex << info_condition->getID() << " ";
          std::cout << "0x";
          std::cout << std::setw(16+1) << std::hex << info_condition->getMask() << " ";
          std::cout << std::dec;
          std::cout << std::setw(10+1) << info_condition->getOffset() << " ";
          if (info_condition->getAcceptDelayed())  { std::cout << "d"; flags = flags | (1<<ECA_DELAYED); }
          else                                     { std::cout << "."; }
          if (info_condition->getAcceptConflict()) { std::cout << "c"; flags = flags | (1<<ECA_CONFLICT); }
          else                                     { std::cout << "."; }
          if (info_condition->getAcceptEarly())    { std::cout << "e"; flags = flags | (1<<ECA_EARLY); }
          else                                     { std::cout << "."; }
          if (info_condition->getAcceptLate())     { std::cout << "l"; flags = flags | (1<<ECA_LATE); }
          else                                     { std::cout << "."; }
          std::cout << " (0x";
          std::cout << std::setw(1) << std::hex << flags << ")  ";
          if (info_condition->getOn())             { std::cout << "Rising   "; }
          else                                     { std::cout << "Falling  "; }
          if (info_condition->getActive())         { std::cout << "Active    "; }
          else                                     { std::cout << "Inactive  "; }
          std::cout << std::dec;
          std::cout << info_condition->getOwner() << " ";
          std::cout << std::endl;
        }
      }
    }

    /* Found IO? */
    if ((io_found == false) &&(ioNameGiven))
    {
      std::cout << "Error: There is no IO with the name " << ioName << "!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }

  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_help() */
/* ==================================================================================================== */
static void io_help (void)
{
  /* Print arguments and options */
  std::cout << "burst control for SAFTlib " << std::endl;
  std::cout << "Usage: " << program << " <unique device name> [OPTIONS]" << std::endl;
  std::cout << std::endl;
  std::cout << "Arguments/[OPTIONS]:" << std::endl;
  std::cout << "  -n <name>:                                     Specify IO name" << std::endl;
  std::cout << std::endl;
  std::cout << "  -f:                                            Get the firmware id of the burst generator" << std::endl;
  std::cout << "  -b <id>:                                       Specify burst ID" << std::endl;
  std::cout << "      id                                           Burst ID, valid IDs: 1.." << N_BURSTS << std::endl;
  std::cout << "  -s <start>:                                    Specify ID of the start event. Requires -n and -b options!" << std::endl;
  std::cout << "  -t <stop>:                                     Specify ID of the stop event. Can be used with the -s option" << std::endl;
  std::cout << "      start, stop                                  IDs of the start and stop events" << std::endl;
  std::cout << "  -p <t_hi> <t_p> <b_p> <b_d> <b_f>:             Define signal parameters to a new/existing burst. Requires -b option!" << std::endl;
  std::cout << "      t_hi, t_p                                    Signal high width (ns), signal period (ns)" << std::endl;
  std::cout << "      b_p, b_d, b_f                                Burst period (ns, =0 endless), burst delay (ns), burst flag (=0 new/overwrite, 1=append)" << std::endl;
  std::cout << "                                                   Limitation: minimum burst period is " << BG_BURST_PERIOD << " ns" << std::endl;
  std::cout << "  -l <0 | id>:                                   List burst(s): 0 for burst IDs, otherwise burst info" << std::endl;
  std::cout << "  -e <id> <disen>:                               Dis/enable burst(s): disable if disen = 0, otherwise enable" << std::endl;
  std::cout << "  -r <id>:                                       Remove burst(s)" << std::endl;
  std::cout << std::endl;
/*  std::cout << "  -i <instr_code> [u32 u32 ...]:                 Instruction to the burst generator, allowed instructions are listed below:" << std::endl;
  std::cout << std::endl;
  std::cout << "      0x1                                        Print the burst parameters. Arguments: burst_id" << std::endl;
  std::cout << "      0x2                                        Obtain the burst parameters. Arguments: burst_id, delay, conditions, block period, flag, verbose" << std::endl;
  std::cout << "      0x3                                        Obtain the block production parameters. Arguments: burst_id, n_block_h32, n_block_l32, verbose" << std::endl;
  std::cout << "      0x10                                       Print MSI configuration" << std::endl;
  std::cout << "      0x11                                       Print ECA channel counters" << std::endl;
  std::cout << "      0x12                                       Print ECA queue content" << std::endl;
  std::cout << "  All print instructions require the eb-console tool to be run to see the output" << std::endl;*/
  std::cout << "  -x:                                            Clear all unowned conditions for the IO and eCPU actions." << std::endl;
  std::cout << "  -o <file>:                                     Load options from a given <file>" << std::endl;
  std::cout << std::endl;
  std::cout << "Examples:" << std::endl << std::endl;
  std::cout << program << " tr0" << " -l 0" << std::endl;
  std::cout << "   List the IDs of all bursts." << std::endl << std::endl;
  std::cout << program << " tr0" << " -l 1 -v" << std::endl;
  std::cout << "   Show the info of a burst with ID 1. It includes the IO port name, IDs of the start and stop events, enable state." << std::endl << std::endl;
  std::cout << program << " tr0" << " -n B1" << " -b 1" << " -s 0x1234567800000000" << std::endl;
  std::cout << "   Create new burst at the output port B1. The burst's ID is 1, the burst is started by a timing message with the event ID of 0x1234567800000000." << std::endl << std::endl;
  std::cout << program << " tr0" << " -b 1" << " -p 1000000 2000000 4000000 0 0" << std::endl;
  std::cout << "   Define signal for the burst with ID 1. The given burst must have already been created! Signal high width is 1 ms, signal period is 2 ms, burst length is 4 ms, no delay." << std::endl << std::endl;
  std::cout << program << " tr0" << " -e 1 1" << std::endl;
  std::cout << "   Enable the burst with ID 1." << std::endl << std::endl;
  std::cout << program << " tr0" << " -r 1" << std::endl;
  std::cout << "   Remove the burst with ID 1." << std::endl;
  std::cout << std::endl;
  std::cout << "Report bugs to <csco-tg@gsi.de>" << std::endl;
  std::cout << "Licensed under the GPLv3" << std::endl;
  std::cout << std::endl;
}

/* Function io_list_i_to_e() */
/* ==================================================================================================== */
static int io_list_i_to_e()
{
  /* Helper  */
  bool printed_header = false;

  /* Get inputs and snoop */
  try
  {
    /* Check inputs */
    for (std::map<std::string,std::string>::iterator it=ins.begin(); it!=ins.end(); ++it)
    {

      if (!printed_header)
      {
        std::cout << "IO             Prefix              Enabled  Event Bit(s)" << std::endl;
        std::cout << "--------------------------------------------------------" << std::endl;
        printed_header = true;
      }
      if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
      {
        /* Set name */
        ioName =  it->first.c_str();
        uint64_t prefix = ECA_EVENT_ID_LATCH + (map_PrefixName.size()*2);
        map_PrefixName[ioName] = prefix;
        std::shared_ptr<Input_Proxy> input = Input_Proxy::create(ins[ioName]);

        std::cout << std::left;
        std::cout << std::setw(12+2) << it->first << " ";
        std::cout << "0x";
        std::cout << std::setw(16+1) << std::hex <<  input->getEventPrefix() << " " << std::dec;
        std::cout << std::setw(3+2);
        if (input->getEventEnable()) { std::cout << "Yes"; }
        else                         { std::cout << "No "; }
        std::cout << "    ";
        std::cout << "0x";
        std::cout << std::setw(10+1) << std::hex <<  input->getEventBits() << " " << std::dec;
        std::cout << std::endl;
      }
    }
  }
  catch (const saftbus::Error& error)
  {
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_catch_input() */
/* ==================================================================================================== */
static void io_catch_input(uint64_t event, uint64_t param, saftlib::Time deadline, saftlib::Time executed, uint16_t flags)
{
  /* Helpers */
  saftlib::Time time = deadline - IO_CONDITION_OFFSET;
  std::string catched_io = "Unknown";

  /* !!! evaluate prefix<>name map */
  for (std::map<std::string,uint64_t>::iterator it=map_PrefixName.begin(); it!=map_PrefixName.end(); ++it) { if (event == it->second) { catched_io = it->first; } } /* Rising */
  for (std::map<std::string,uint64_t>::iterator it=map_PrefixName.begin(); it!=map_PrefixName.end(); ++it) { if (event-1 == it->second) { catched_io = it->first; } } /* Falling */

  /* Format output */
  std::cout << std::left;
  std::cout << std::setw(12+2) << catched_io << " ";
  if ((event&1)) { std::cout << "Rising   "; }
  else           { std::cout << "Falling  "; }
  if (flags & (1 << ECA_DELAYED))  { std::cout << "d"; }
  else                             { std::cout << "."; }
  if (flags & (1 << ECA_CONFLICT)) { std::cout << "c"; }
  else                             { std::cout << "."; }
  if (flags & (1 << ECA_EARLY))    { std::cout << "e"; }
  else                             { std::cout << "."; }
  if (flags & (1 << ECA_LATE))     { std::cout << "l"; }
  else                             { std::cout << "."; }
  std::cout << " (0x";
  std::cout << std::setw(1) << std::hex << flags << ")  ";
  std::cout << "0x" << std::hex << setw(16+1) << event << std::dec << " ";
  std::cout << "0x" << std::hex << setw(16+1) << (UTC?time.getUTC():time.getTAI()) << std::dec << " " << tr_formatDate(time,PMODE_VERBOSE|(UTC?PMODE_UTC:PMODE_NONE));
  std::cout << std::endl;
}

/* Function io_snoop() */
/* ==================================================================================================== */
static int io_snoop(bool mode, bool setup_only, bool disable_source, uint64_t prefix_custom)
{
  /* Helpers (connect proxies in a vector) */
  std::vector <std::shared_ptr<SoftwareCondition_Proxy> > proxies;
  std::vector <std::shared_ptr<SoftwareActionSink_Proxy> > sinks;

  /* Get inputs and snoop */
  try
  {
    /* Check inputs */
    for (std::map<std::string,std::string>::iterator it=ins.begin(); it!=ins.end(); ++it)
    {
      if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
      {
        /* Set name */
        ioName =  it->first.c_str();
        uint64_t prefix = ECA_EVENT_ID_LATCH + (map_PrefixName.size()*2);
        map_PrefixName[ioName] = prefix;

        /* Create sink and condition or turn off event source */
        if (!mode)
        {
          if (!setup_only)
          {
            sinks.push_back( SoftwareActionSink_Proxy::create(tr->NewSoftwareActionSink("")));
            proxies.push_back( SoftwareCondition_Proxy::create(sinks.back()->NewCondition(true, prefix, -2, IO_CONDITION_OFFSET)));
            proxies.back()->SigAction.connect(sigc::ptr_fun(&io_catch_input));
            proxies.back()->setAcceptConflict(true);
            proxies.back()->setAcceptDelayed(true);
            proxies.back()->setAcceptEarly(true);
            proxies.back()->setAcceptLate(true);
          }

          /* Setup the event */
          std::shared_ptr<Input_Proxy> input = Input_Proxy::create(ins[ioName]);
          if (prefix_custom != 0x0) { prefix = prefix_custom; }
          if (disable_source)
          {
            input->setEventEnable(false);
          }
          else
          {
            input->setEventEnable(false);
            input->setEventPrefix(prefix);
            input->setEventEnable(true);
          }
        }
        else
        {
          /* Disable the event */
          std::shared_ptr<Input_Proxy> input = Input_Proxy::create(ins[ioName]);
          input->setEventEnable(false);
        }
      }
    }

    /* Disabled? */
    if (mode) { return (__IO_RETURN_SUCCESS); }

    /* Run the loop printing IO events (in case we found inputs */
    if (map_PrefixName.size())
    {
      if (!setup_only)
      {
        std::cout << "IO             Edge     Flags       ID                  Timestamp           Formatted Date               " << std::endl;
        std::cout << "---------------------------------------------------------------------------------------------------------" << std::endl;
        while(true) {
          saftlib::wait_for_signal();
        }
      }
    }
    else
    {
      std::cout << "This Timing Receiver has no inputs!" << std::endl;
    }

  }
  catch (const saftbus::Error& error)
  {
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_setup() */
/* ==================================================================================================== */
static int io_setup (int io_oe, int io_term, int io_spec_out, int io_spec_in, int io_gate_out, int io_gate_in, int io_mux, int io_pps, int io_drive, int s_time,
                    bool set_oe, bool set_term, bool set_spec_out, bool set_spec_in, bool set_gate_out, bool set_gate_in, bool set_mux, bool set_pps, bool set_drive, bool set_stime,
                    bool verbose_mode)
{
  unsigned io_type  = 0;     /* Out, Inout or In? */
  bool     io_found = false; /* IO exists? */
  bool     io_set   = false; /* IO set or get configuration */

  /* Check if there is at least one parameter to set */
  io_set = set_oe | set_term | set_spec_out | set_spec_in | set_mux | set_pps | set_drive | set_stime | set_gate_out | set_gate_in;

  /* Display information */
  if (verbose_mode)
  {
    if (io_set) { std::cout << "Checking configuration feasibility..." << std::endl; }
    else        { std::cout << "Checking current configuration..." << std::endl; }
  }

  /* Plausibility check for io name */
  if (ioName == NULL)
  {
    std::cout << "Error: No IO name provided!" << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Initialize saftlib components */

  /* Perform selected action(s) */
  try
  {
    /* Search for IO name */
    std::string io_path;
    std::string io_partner;
    std::shared_ptr<Output_Proxy> output_proxy;
    std::shared_ptr<Input_Proxy> input_proxy;

    /* Check if IO exists as input */
    for (std::map<std::string,std::string>::iterator it=ins.begin(); it!=ins.end(); ++it)
    {
      if (it->first == ioName)
      {
        io_found = true;
        io_type = IO_CFG_FIELD_DIR_INPUT;
        input_proxy = Input_Proxy::create(it->second);
        io_path = it->second;
      }
    }

    /* Check if IO exists output */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      if (it->first == ioName)
      {
        io_found = true;
        io_type = IO_CFG_FIELD_DIR_OUTPUT;
        output_proxy = Output_Proxy::create(it->second);
        io_path = it->second;
      }
    }

    /* Found IO? */
    if (io_found == false)
    {
      std::cout << "Error: There is no IO with the name " << ioName << "!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }
    else
    {
      if (verbose_mode) { std::cout << "Info: Found " << ioName << " (" << io_type << ")" << "!" << std::endl; }
    }

    /* Check if IO is bidirectional */
    if (io_type == IO_CFG_FIELD_DIR_INPUT)
    {
      io_partner = input_proxy->getOutput();
      if (io_partner != "") { io_type = IO_CFG_FIELD_DIR_INOUT; }
    }
    else if (io_type == IO_CFG_FIELD_DIR_OUTPUT)
    {
      io_partner = output_proxy->getInput();
      if (io_partner != "") { io_type = IO_CFG_FIELD_DIR_INOUT; }
    }
    else
    {
      std::cout << "IO direction is unknown!" << std::endl;
      return (__IO_RETURN_FAILURE);
    }

    /* Switch: Set something or get the current status) ?*/
    if (io_set)
    {
      /* Check oe configuration */
      if (set_oe)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }

        /* Check if OE option is available */
        if (!(output_proxy->getOutputEnableAvailable()))
        {
          std::cout << "Error: This option does not exist for this IO!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check term configuration */
      if (set_term)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_OUTPUT)
        {
          std::cout << "Error: This option is not available for outputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
        /* Check if TERM option is available */
        if (!(input_proxy->getInputTerminationAvailable()))
        {
          std::cout << "Error: This option does not exist for this IO!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check special out configuration */
      if (set_spec_out)
      {
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
        /* Check if SPEC OUT option is available */
        if (!(output_proxy->getSpecialPurposeOutAvailable()))
        {
          std::cout << "Error: This option does not exist for this IO!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check special in configuration */
      if (set_spec_in)
      {
        if (io_type == IO_CFG_FIELD_DIR_OUTPUT)
        {
          std::cout << "Error: This option is not available for outputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
        /* Check if SPEC OUT option is available */
        if (!(input_proxy->getSpecialPurposeInAvailable()))
        {
          std::cout << "Error: This option does not exist for this IO!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check gate out configuration */
      if (set_gate_out)
      {
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check gate in configuration */
      if (set_gate_in)
      {
        if (io_type == IO_CFG_FIELD_DIR_OUTPUT)
        {
          std::cout << "Error: This option is not available for outputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check multiplexer (BuTiS support) */
      if (set_mux)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check PPS gate */
      if (set_pps)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check if IO can be driven */
      if (set_drive)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_INPUT)
        {
          std::cout << "Error: This option is not available for inputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Check if stable time can beset */
      if (set_stime)
      {
        /* Plausibility check */
        if (io_type == IO_CFG_FIELD_DIR_OUTPUT)
        {
          std::cout << "Error: This option is not available for outputs!" << std::endl;
          return (__IO_RETURN_FAILURE);
        }
      }

      /* Set configuration */
      if (set_oe)       { output_proxy->setOutputEnable(io_oe); }
      if (set_term)     { input_proxy->setInputTermination(io_term); }
      if (set_spec_out) { output_proxy->setSpecialPurposeOut(io_spec_out); }
      if (set_spec_in)  { input_proxy->setSpecialPurposeIn(io_spec_in); }
      if (set_gate_out) { output_proxy->setGateOut(io_gate_out); }
      if (set_gate_in)  { input_proxy->setGateIn(io_gate_in); }
      if (set_mux)      { output_proxy->setBuTiSMultiplexer(io_mux); }
      if (set_pps)      { output_proxy->setPPSMultiplexer(io_pps); }
      if (set_drive)    { output_proxy->WriteOutput(io_drive); }
      if (set_stime)    { input_proxy->setStableTime(s_time); }
    }
    else
    {
      /* Generic information */
      std::cout << "IO:" << std::endl;
      std::cout << "  Path:    " << io_path << std::endl;
      if (io_partner != "") { std::cout << "  Partner: " << io_partner << std::endl; }
      std::cout << std::endl;

      /* Display configuration */
      std::cout << "Current state:" << std::endl;
      if (io_type != IO_CFG_FIELD_DIR_INPUT)
      {
        /* Display output */
        if (output_proxy->ReadOutput())             { std::cout << "  Output:           High" << std::endl; }
        else                                        { std::cout << "  Output:           Low" << std::endl; }

        /* Display output enable state */
        if (output_proxy->getOutputEnableAvailable())
        {
          if (output_proxy->getOutputEnable())      { std::cout << "  OutputEnable:     On" << std::endl; }
          else                                      { std::cout << "  OutputEnable:     Off" << std::endl; }
        }

        /* Display special out state */
        if (output_proxy->getSpecialPurposeOutAvailable())
        {
          if (output_proxy->getSpecialPurposeOut()) { std::cout << "  SpecialOut:       On" << std::endl; }
          else                                      { std::cout << "  SpecialOut:       Off" << std::endl; }
        }

        /* Display gate out state */
        if (output_proxy->getGateOut())             { std::cout << "  GateOut:          On" << std::endl; }
        else                                        { std::cout << "  GateOut:          Off" << std::endl; }

        /* Display BuTiS multiplexer state */
        if (output_proxy->getBuTiSMultiplexer())    { std::cout << "  BuTiS t0 + TS:    On" << std::endl; }
        else                                        { std::cout << "  BuTiS t0 + TS:    Off" << std::endl; }

        /* Display WR PPS multiplexer state */
        if (output_proxy->getPPSMultiplexer())      { std::cout << "  WR PPS:           On" << std::endl; }
        else                                        { std::cout << "  WR PPS:           Off" << std::endl; }

        /* Display IO index */
        std::cout << "  IndexOut:         " << output_proxy->getIndexOut() << std::endl;

      }

      if (io_type != IO_CFG_FIELD_DIR_OUTPUT)
      {
        /* Display input */
        if (input_proxy->ReadInput())               { std::cout << "  Input:            High" << std::endl; }
        else                                        { std::cout << "  Input:            Low" << std::endl; }

        /* Display output enable state */
        if (input_proxy->getInputTerminationAvailable())
        {
          if (input_proxy->getInputTermination())   { std::cout << "  InputTermination: On" << std::endl; }
          else                                      { std::cout << "  InputTermination: Off" << std::endl; }
        }

        /* Display special in state */
        if (input_proxy->getSpecialPurposeInAvailable())
        {
          if (input_proxy->getSpecialPurposeIn())   { std::cout << "  SpecialIn:        On" << std::endl; }
          else                                      { std::cout << "  SpecialIn:        Off" << std::endl; }
        }

        /* Display gate in state */
        if (input_proxy->getGateIn())               { std::cout << "  GateIn:           On" << std::endl; }
        else                                        { std::cout << "  GateIn:           Off" << std::endl; }

        /* Display stable time */
        std::cout << "  StableTime:       " << input_proxy->getStableTime() << " ns" << std::endl;

        /* Display IO index */
        std::cout << "  IndexIn:          " << input_proxy->getIndexIn() << std::endl;
      }
    }
  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function io_print_table() */
/* ==================================================================================================== */
static int io_print_table(bool verbose_mode)
{
  /* Initialize saftlib components */

  /* Try to get the table */
  try
  {
    /* Show verbose output */
    if (verbose_mode)
    {
      std::cout << "Discovered Output(s): " << std::endl;
      for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
      {
        std::cout << it->first << " => " << it->second << '\n';
      }
      std::cout << "Discovered Inputs(s) " << std::endl;
      for (std::map<std::string,std::string>::iterator it=ins.begin(); it!=ins.end(); ++it)
      {
        std::cout << it->first << " => " << it->second << '\n';
      }
    }

    /* Print table header */
    std::cout << "Name           Direction  OutputEnable  InputTermination  SpecialOut  SpecialIn  Resolution  Logic Level" << std::endl;
    std::cout << "--------------------------------------------------------------------------------------------------------" << std::endl;

    /* Print Outputs */
    for (std::map<std::string,std::string>::iterator it=outs.begin(); it!=outs.end(); ++it)
    {
      if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
      {
        std::shared_ptr<Output_Proxy> output_proxy;
        output_proxy = Output_Proxy::create(it->second);
        std::cout << std::left;
        std::cout << std::setw(12+2) << it->first << " ";
        std::cout << std::setw(5+6)  << "Out ";
        std::cout << std::setw(3+11);
        if(output_proxy->getOutputEnableAvailable()) { std::cout << "Yes"; }
        else                                         { std::cout << "No"; }
        std::cout << std::setw(3+15);
        std::cout << "No"; /* InputTermination */
        std::cout << std::setw(5+7);
        if(output_proxy->getSpecialPurposeOutAvailable()) { std::cout << "Yes"; }
        else                                              { std::cout << "No"; }
        std::cout << std::setw(3+8);
        std::cout << "No"; /* SpecialOut */
        std::cout << output_proxy->getTypeOut();
        std::cout << "  ";
        std::cout << output_proxy->getLogicLevelOut();
        std::cout << std::endl;
      }
    }

    /* Print Inputs */
    for (std::map<std::string,std::string>::iterator it=ins.begin(); it!=ins.end(); ++it)
    {
      if (((ioNameGiven && (it->first == ioName)) || !ioNameGiven))
      {
        std::shared_ptr<Input_Proxy> input_proxy;
        input_proxy = Input_Proxy::create(it->second);
        std::cout << std::left;
        std::cout << std::setw(12+2) << it->first << " ";
        std::cout << std::setw(5+6)  << "In ";
        std::cout << std::setw(3+11);
        std::cout << "No";
        std::cout << std::setw(3+15);
        if(input_proxy->getInputTerminationAvailable()) { std::cout << "Yes"; }
        else                                            { std::cout << "No"; }
        std::cout << std::setw(5+7);
        std::cout << "No";
        std::cout << std::setw(3+8);
        if(input_proxy->getSpecialPurposeInAvailable()) { std::cout << "Yes"; }
        else                                            { std::cout << "No"; }
        std::cout << input_proxy->getTypeIn();
        std::cout << "  ";
        std::cout << input_proxy->getLogicLevelIn();
        std::cout << std::endl;
      }
    }

  }
  catch (const saftbus::Error& error)
  {
    /* Catch error(s) */
    std::cerr << "Failed to invoke method: " << error.what() << std::endl;
    return (__IO_RETURN_FAILURE);
  }

  /* Done */
  return (__IO_RETURN_SUCCESS);
}

/* Function main() */
/* ==================================================================================================== */
int main (int argc, char** argv)
{
  int status = __BG_RETURN_SUCCESS;

  /* Get the application name */
  program = argv[0];

  /* Evaluate the command line arguments */
  if (argc > 2) {
    if (argv[1] != NULL)
      deviceName = argv[1];

    string cmd_args;
    for (int i = 1; i < argc; ++i)
      cmd_args.append(string(argv[i]) + " ");

    cout << "Command args: " << cmd_args << endl;

    // check if an option file is specified
    while((opt = getopt(argc, argv, ":ho:")) != -1) {
      switch (opt) {
        case 'h':
          show_help = true;
          break;
        case 'o':
          if (argv[optind-1] != NULL) {
            optFileName = string(argv[optind-1]);
            // remove option and its argument from cmd_args
            string what = "-o";
            string::size_type n = cmd_args.rfind(what);
            if (n != string::npos)
              cmd_args.erase(n, what.length());
            n = cmd_args.rfind(optFileName);
            if (n != string::npos)
              cmd_args.erase(n, optFileName.length());

            // check any option
            n = cmd_args.find('-');
            if (0 < n && n + 1 < cmd_args.length())
              if (!std::isspace(static_cast<unsigned char>(cmd_args[n-1])) &&
                  !std::isalpha(static_cast<unsigned char>(cmd_args[n+1])))
                n = string::npos;

            // no option at all
            if (n == string::npos)
              cmd_args.clear();
          }
          else {
            std::cerr << "Error: Missing file name!" << std::endl;
            show_help = true;
          }
          break;
        case ':':
          std::cout << "Option -" << (char)optopt << " requires argument(s)!" << std::endl;
          show_help = true;
          break;
        default:
          break;
      }
    }

    if (show_help) {
      io_help();
      return 0;
    }

    if (!cmd_args.empty())
      bg_options.push_back(cmd_args);
  }
  else {
    cerr << "Error: Missing options!" << endl;
    io_help();
    return -1;
  }

  /* Get options from the specified option file */
  if (!optFileName.empty()) {

    cout << "Content in file " << optFileName << ":"<< endl;

    ifstream file(optFileName);
    if (file) {
      string line;
      while(getline(file, line)) {
        cout << line << endl;
        if (line.length() != 0)           // ignore empty line
          bg_options.push_back(line);
      }
    }
    else {
      cerr << "Error: Trouble with " << optFileName << endl;
      return -1;
    }
  }

  /* Check if any command-line option is given */
  if (bg_options.empty()) {
    cout << "No option to proceed. Exit" << endl;
    return 0;
  }

  /* Detect a given target device */
  cout << "Detecting target device: " << deviceName << endl;
  if (deviceName != NULL) {
    if (bg_setup_device(deviceName))
    {
      cerr << "Failed to set up " << deviceName << endl;
      return -1;
    }

    cout << "Device " << deviceName << " found!" << endl;
  }
  else {
    cerr << "Error: device name is missing!" << endl;
    return -1;
  }

  /* Remove comments (lines starting with '#') and resize the container */
  vector<string>::iterator itr = remove_if(bg_options.begin(), bg_options.end(), bg_is_comment);
  bg_options.erase(itr, bg_options.end());

  cout << "Options to process:" << endl;
  itr = bg_options.begin();
  while (itr != bg_options.end()) {
    cout << "<" << *itr << ">" << endl;
    ++itr;
  }

  bg_reset_variables();
  cout << "Starting configuration ..." << endl;

  /* Parse the command-line options, check their arguments and configure the target */
  itr = bg_options.begin();
  while (itr != bg_options.end()) {
    // parse options
    if (bg_parse_options(*itr, ":fp:e:i:l:b:r:s:t:xn:v"))
      cerr << "Cannot parse options: " << *itr << endl;
    else
    {
      // check arguments
      if (bg_check_arguments())
        cerr << "Bad arguments in options: " << *itr << endl;
      else
      {
        // do configuration
        status = bg_do_configuration();
        if (status) {
          cerr << "Failed options: " << *itr << endl;
          return status;
        }
        else
          cout << "Successed: " << *itr << endl;
      }

      bg_reset_variables();
    }
    ++itr;
  }

  /* Done */
  return 0;
}
